{"text": "Giáo trình Lập trình căn bản \n Lâm Hoài Bảo , Dương Văn Hiếu , Nguyễn Văn Linh \n Khoa Công Nghệ Thông Tin & Truyền Thông , Đại Học Cần Thơ \n 2005", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 1}}
{"text": "Lập trình căn bản \n MỤC LỤC \n Mở đầu \n Chương 1 : GIẢI THUẬT VÀ BIỂU DIỄN GIẢI THUẬT \n Chương 2 : TỔNG QUAN VỀ NGÔN NGỮ LẬP TRÌNH C \n Chương 3 : CÁC CÂU LỆNH ĐƠN TRONG C \n Chương 4 : CÁC LỆNH CÓ CẤU TRÚC \n Chương 5 : CHƯƠNG TRÌNH CON ( HÀM ) \n Chương 6 : MẢNG \n Chương 7 : CON TRỎ \n Chương 8 : CHUỖI KÝ TỰ \n Chương 9 : KIỂU CẤU TRÚC – STRUCT \n Chương 10 : TẬP TIN \n TÀI LIỆU THAM KHẢO", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 2}}
{"text": "Lập trình căn bản \n MỞ ĐẦU \n I. MỤC ĐÍCH \n Quyển sách này cung cấp cho người đọc những kiến thức cơ bản \n về lập trình thông qua ngôn ngữ lập trình C. Đây là cơ sở để \n người đọc từng bước tiếp cận với thế giới lập trình , từ đó người \n đọc có một nền tảng vững chắc để có thể tiếp thu hầu hết các lĩnh \n vực trong chuyên ngành Công Nghệ Thông Tin . \n Các vấn đề chính được trình bày trong quyển sách này : \n  Các khái niệm : ngôn ngữ lập trình , kiểu dữ liệu . \n  Khái niệm giải thuật và biểu diễn giải thuật \n  Ngôn ngữ lập trình C ( sau đây gọi tắt là C ) : \n  Các thành phần của C. \n  Các kiểu dữ liệu trong C. \n  Các câu lệnh trong C. \n  Cách thiết kế và sử dụng các hàm trong C. \n  Một số cấu trúc dữ liệu trong C.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 3}}
{"text": "Lập trình căn bản \n Chương 1 \n GIẢI THUẬT VÀ BIỂU DIỄN GIẢI THUẬT \n Các vấn đề được trình bày trong chương này : \n  Từ bài toán đến chương trình \n  Giải thuật và biểu diễn giải thuật \n  Một số khái niệm : kiểu dữ liệu , ngôn ngữ lập trình , chương \n trình dịch \n Nội dung chính của chương này là giải thuật & các cách biểu \n diễn giải thuật . Lý do vì chương trình máy tính của một bài toán \n cụ thể được tạo ra từ các biểu diễn của giải thuật . \n I. TỪ BÀI TOÁN ĐẾN CHƯƠNG TRÌNH \n Theo [ 6 ] , mọi bài toán đều có thể được diễn giải theo một sơ \n đồ chung : A  B \n Trong đó : \n  A là giả thiết , là điều kiện ban đầu . \n  B là kết luận , là mục tiêu cần đạt hoặc là cái phải tìm . \n   là suy luận , là giải pháp cần thực hiện để tìm B từ cái đã \n biết A. \n Một bài toán trên máy tính cũng mang đầy đủ các tính chất của \n bài toán ở trên . Trong đó : \n  A là thông tin vào ( đầu vào - input ) \n  B là thông tin ra ( đầu ra - output ) \n   là chương trình tạo ra từ các lệnh cơ bản của máy tính \n cho phép tạo B từ A. \n Như vậy , việc giải một bài toán trên máy tính là việc xác định \n các yếu tố đầu vào , đầu ra cũng như xác định cách giải quyết bài \n toán bằng chương trình máy tính .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 4}}
{"text": "tính \n cho phép tạo B từ A. \n Như vậy , việc giải một bài toán trên máy tính là việc xác định \n các yếu tố đầu vào , đầu ra cũng như xác định cách giải quyết bài \n toán bằng chương trình máy tính .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 4}}
{"text": "Lập trình căn bản \n Thí dụ : Giả sử có hai bình B1 và B2 đựng hai loại chất lỏng \n khác nhau , chẳng hạn bình B1 đựng rượu , bình B2 đựng nước \n mắm . Làm thế nào để hoán đổi chất lỏng trong 02 bình , tức bình \n B1 đựng nước mắm , bình B2 đựng rượu ? \n  Đầu vào của bài toán là 02 bình B1 , B2 với mỗi bình lần \n lượt chứa rượu và nước mắm . \n  Đầu ra của bài toán là bình B1 chứa nước mắm , bình B2 \n chứa rượu . \n  Một dãy các bước để thực hiện bài toán này là : \n o Có thêm một bình thứ ba gọi là B3 . \n o Bước 1 : Đổ rượu từ bình B1 vào bình B3 . \n o Bước 2 : Đổ nước mắm từ bình B2 sang bình B1 . \n o Bước 3 : Đổ rượu từ bình B3 sang B2 . \n Trong thí dụ trên , dãy các bước để thực hiện bài toán hoán \n đổi chất lỏng trong 02 bình chưa phải là 1 chương trình . Tuy \n nhiên chương trình máy tính thực hiện bài toán này được cài đặt \n với các lệnh được mô tả gần với cách mô tả trong dãy các bước \n trên . Dãy các bước trên còn được gọi là giải thuật để giải bài toán \n hoán đổi chất lỏng trong 02 bình trên . \n II. GIẢI THUẬT \n II. 1 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 5}}
{"text": "02 bình trên . \n II. GIẢI THUẬT \n II. 1 . Khái niệm giải thuật \n Giải thuật là một hệ thống chặt chẽ và rõ ràng các quy tắc \n nhằm xác định một dãy các thao tác trên những dữ liệu vào sao \n cho sau một số hữu hạn bước thực hiện các thao tác đó ta thu \n được kết quả của bài toán . \n Thí dụ : Tìm ước số chung lớn nhất của 2 số nguyên a , b . \n  Đầu vào : 2 số nguyên a , b . \n  Đầu ra : ước số chung lớn nhất của a , b \n  Giải thuật : \n o Bước 1 : Nhập vào hai số a và b .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 5}}
{"text": "Lập trình căn bản \n o Bước 2 : So sánh 2 số a , b chọn số nhỏ nhất gán cho \n UCLN. \n o Bước 3 : Nếu một trong hai số a hoặc b không chia hết cho \n UCLN thì thực hiện bước 4 , ngược lại ( cả a và b đều chia \n hết cho UCLN ) thì thực hiện bước 5 . \n o Bước 4 : Giảm UCLN một đơn vị và quay lại bước 3 \n o Bước 5 : In UCLN - Kết thúc . \n II. 2 Các đặc trưng của giải thuật \n  Tính kết thúc : Giải thuật phải dừng sau một số hữu hạn \n bước . \n  Tính xác định : Các thao tác máy tính phải thực hiện được và \n các máy tính khác nhau thực hiện cùng một bước của cùng một \n giải thuật phải cho cùng một kết quả . \n  Tính phổ dụng : Giải thuật phải \" vét ' hết các trường hợp và \n áp dụng cho một loạt bài toán cùng loại . \n  Tính hiệu quả : Một giải thuật được đánh giá là tốt nếu nó đạt \n hai tiêu chuẩn sau : \n o Thực hiện nhanh , tốn ít thời gian . \n o Tiêu phí ít tài nguyên của máy , chẳng hạn tốn ít bộ nhớ . \n Giải thuật tìm UCLN nêu trên đạt tính kết thúc bởi vì qua mỗi \n lần thực hiện bước 4 thì UCLN sẽ giảm đi một đơn vị cho nên \n trong trường hợp xấu nhất thì UCLN = 1 , giải thuật phải dừng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 6}}
{"text": "ì UCLN sẽ giảm đi một đơn vị cho nên \n trong trường hợp xấu nhất thì UCLN = 1 , giải thuật phải dừng . \n Các thao tác trình bày trong các bước , máy tính đều có thể thực \n hiện được nên nó có tính xác định . Giải thuật này cũng đạt tính \n phổ dụng vì nó được dùng để tìm UCLN cho hai số nguyên \n dương a và b bất kỳ . Tuy nhiên tính hiệu quả của giải thuật có thể \n chưa cao ; cụ thể là thời gian chạy máy có thể còn tốn nhiều hơn \n một số giải thuật khác ` mà chúng ta sẽ có dịp trở lại trong các \n chương tiếp theo . \n II. 3 Ngôn ngữ biểu diễn giải thuật \n Để biểu diễn giải thuật , cần phải có một tập hợp các ký hiệu dùng \n để biểu diễn , mỗi ký hiệu biểu diễn cho một hành động nào đó . \n Tập hợp các ký hiệu đó lại tạo thành ngôn ngữ biểu diễn giải \n thuật .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 6}}
{"text": "Lập trình căn bản \n II. 3.1 Ngôn ngữ tự nhiên \n Ngôn ngữ tự nhiên là ngôn ngữ của chúng ta đang sử dụng . \n Chẳng hạn , các thí dụ ở trên dùng ngôn ngữ tự nhiên để biểu diễn \n giải thuật . \n Thí dụ : Giải thuật giải phương trình bậc nhất dạng ax + b = 0 \n như sau : \n  Đầu vào : 2 số thực a , b . \n  Đầu ra : Các kết luận về các trường hợp nghiệm của \n phương trình ax + b = 0 . \n  Giải thuật : \n o Bước 1 : Nhận giá trị của các tham số a , b \n o Bước 2 : Xét giá trị của a xem có bằng 0 hay không ? Nếu \n a = 0 thì làm bước 3 , nếu a khác không thì làm bước 4 . \n o Bước 3 : ( a bằng 0 ) Nếu b bằng 0 thì ta kết luận phương \n trình vô số nghiệm , nếu b khác 0 thì ta kết luận phương \n trình vô nghiệm . \n o Bước 4 : ( a khác 0 ) Kết luận phương trình có nghiệm \n x = - b / a . \n II. 3.2 Lưu đồ \n Lưu đồ là một tập ký hiệu trực quan dùng để thể hiện giải thuật . \n Các ký hiệu được sử dụng trong lưu đồ được cho trong bảng sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 7}}
{"text": "Lập trình căn bản\n\n| Ký hiệu | Ý nghĩa |\n| --- | --- |\n|  | Bắt đầu/ Kết thúc |\n|  | Nhập/Xuất |\n|  | Tính toán (xử lý) |\n|  | Quyết định và rẽ nhánh |\n|  | Khối nối |\n|  | Đường đi |\n\n\nChẳng hạn lưu đồ để biểu diễn giải thuật tìm ước số chung lớn \n nhất theo cách thức như trên là :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 8}}
{"text": "Lập trình căn bản \n II. 3.3 Một số thí dụ \n Thí dụ 1 : Cần viết chương trình cho máy tính sao cho khi thực \n hiện chương trình đó , máy tính yêu cầu người sử dụng chương \n trình nhập vào các số hạng của tổng ( n ) ; nhập vào dãy các số \n hạng a của tổng . Sau đó , máy tính sẽ thực hiện việc tính tổng các \n i \n số a này và in kết quả của tổng tính được . \n i \n Yêu cầu : Tính tổng n số S = a + a + a + ... ... + a . \n 1 2 3 n \n Để tính tổng trên , chúng ta sử dụng phương pháp “ cộng \n tích lũy ” nghĩa là khởi đầu cho S = 0 . Sau mỗi lần nhận được một \n số hạng a từ bàn phím , ta cộng tích lũy a vào S ( lấy giá trị được \n i i \n lưu trữ trong S , cộng thêm a và lưu trở lại vào S ) . Tiếp tục quá \n i \n trình này đến khi ta tích lũy được a vào S thì ta có S là tổng các \n n \n a . Chi tiết giải thuật được mô tả bằng ngôn ngữ tự nhiên như sau : \n i \n o Bước 1 : Nhập số các số hạng n . \n o Bước 2 : Cho S = 0 ( lưu trữ số 0 trong S ) \n o Bước 3 : Cho i = 1 ( lưu trữ số 1 trong i ) \n o Bước 4 : Kiểm tra nếu i < = n thì thực hiện bước 5 , ngược lại \n thực hiện bước 8 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 9}}
{"text": "m tra nếu i < = n thì thực hiện bước 5 , ngược lại \n thực hiện bước 8 . \n o Bước 5 : Nhập a \n i \n o Bước 6 : Cho S = S + a ( lưu trữ giá trị S + a trong S ) \n i i \n o Bước 7 : Tăng i lên 1 đơn vị và quay lại bước 4 . \n o Bước 8 : In S và kết thúc chương trình . \n Chi tiết giải thuật trên bằng lưu đồ :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 9}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Viết chương trình cho phép nhập vào 2 giá trị a , b \n mang ý nghĩa là các hệ số a , b của phương trình bậc nhất . Dựa \n vào các giá trị a , b đó cho biết nghiệm của phương trình bậc nhất \n ax + b = 0 . \n Mô tả giải thuật bằng ngôn ngữ tự nhiên ( trang 6 ) \n Lưu đồ của giải thuật giải phương trình bậc nhất :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 10}}
{"text": "Lập trình căn bản \n Thí dụ 3 : Viết chương trình cho phép nhập vào 1 số n , sau đó \n lần lượt nhập vào n giá trị a , a , … , a . Hãy tìm và in ra giá trị lớn \n 1 2 n \n nhất trong n số a , a , … , a . \n 1 2 n \n Để giải quyết bài toán trên , chúng ta áp dụng phương pháp \n “ thử và sửa ” . Ban đầu giả sử a là số lớn nhất ( được lưu trong giá \n 1 \n trị max ) ; sau đó lần lượt xét các a còn lại , nếu a nào lớn hơn giá \n i i \n trị max thi lúc đó max sẽ nhận giá trị là a . Sau khi đã xét hết các \n i \n a thì max chính là giá trị lớn nhất cần tìm . \n i \n Mô tả giải thuật bằng ngôn ngữ tự nhiên : \n o Bước 1 : Nhập số n \n o Bước 2 : Nhập số thứ nhất a \n 1 \n o Bước 3 : Gán max = a \n 1 \n o Bước 4 : Gán i = 2 \n o Bước 5 : Nếu i < = n thì thực hiện bước 6 , ngược lại thực \n hiện bước 9 \n o Bước 6 : Nhập a \n i \n o Bước 7 : Nếu max < a thì gán max = a . \n i i \n o Bước 8 : Tăng i lên một đơn vị và quay lại bước 5 \n o Bước 9 : In max - kết thúc \n Phần mô tả giải thuật bằng lưu đồ , độc giả có thể xem như 1 \n bài tập . \n Thí dụ 4 : Viết chương trình cho phép nhập vào 1 số n , sau đó \n lần lượt nhập vào n giá trị a , a , … , a . Sắp theo thứ tự tăng dần \n 1 2 n \n một dãy n số a , a , ... a nói trên .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 11}}
{"text": "1 \n bài tập . \n Thí dụ 4 : Viết chương trình cho phép nhập vào 1 số n , sau đó \n lần lượt nhập vào n giá trị a , a , … , a . Sắp theo thứ tự tăng dần \n 1 2 n \n một dãy n số a , a , ... a nói trên . \n 1 2 n \n Dưới đây là một trong những phương pháp để sắp xếp thứ tự \n 1 dãy các số : \n Giả sử ta đã nhập vào 1 dãy n số a , a , ... , a . Việc sắp xếp dãy \n 1 2 n \n số này trải qua ( n - 1 ) lần : \n  Lần 1 : So sánh phần tử đầu tiên với tất cả các phần tử đứng \n sau phần tử đầu tiên . Nếu có phần tử nào nhỏ hơn phần tử đầu \n tiên thì đổi chỗ phần tử đầu tiên với phần tử nhỏ hơn đó . Sau \n lần 1 , ta được phần tử đầu tiên là phần tử nhỏ nhất .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 11}}
{"text": "Lập trình căn bản \n  Lần 2 : So sánh phần tử thứ 2 với tất cả các phần tử đứng \n sau phần tử thứ 2 . Nếu có phần tử nào nhỏ hơn phần tử thứ 2 \n thì đổi chỗ phần tử thứ 2 với phần tử nhỏ hơn đó . Sau lần 2 , \n ta được phần tử đầu tiên và phần tử thứ 2 là đúng vị trí của nó \n khi sắp xếp . \n  … \n  Lần ( n - 1 ) : So sánh phần tử thứ ( n - 1 ) với phần tử đứng sau \n phần tử ( n - 1 ) là phần tử thứ n . Nếu phần tử thứ n nhỏ hơn \n phần tử thứ ( n - 1 ) thì đổi chỗ 2 phần tử này . \n Sau lần thứ ( n - 1 ) , ta được danh sách gồm n phần tử được sắp \n thứ tự . \n Mô tả giải thuật bằng ngôn ngữ tự nhiên : \n o Bước 1 : Gán i = 1 \n o Bước 2 : Gán j = i + 1 \n o Bước 3 : Nếu i < = n - 1 thì thực hiện bước 4 , ngược lại thực \n hiện bước 8 \n o Bước 4 : Nếu j < = n thì thực hiện bước 5 , ngược lại thì thực \n hiện bước 7 . \n o Bước 5 : Nếu a > a thì hoán đổi a và a cho nhau ( nếu \n i j i j \n không thì thôi ) . \n o Bước 6 : Tăng j lên một đơn vị và quay lại bước 4 \n o Bước 7 : Tăng i lên một đơn vị và quay lại bước 3 \n o Bước 8 : In dãy số a , a , ... , a - Kết thúc . \n 1 2 n \n II.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 12}}
{"text": "quay lại bước 3 \n o Bước 8 : In dãy số a , a , ... , a - Kết thúc . \n 1 2 n \n II. 4 Các cấu trúc suy luận cơ bản của giải thuật \n Giải thuật được thiết kế theo các cấu trúc suy luận cơ bản sau \n đây : \n II. 4.1 Tuần tự ( Sequential ) : Các công việc được thực hiện một \n cách tuần tự , công việc này nối tiếp công việc kia .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 12}}
{"text": "Lập trình căn bản \n II. 4.2 Lựa chọn ( Selection ) : Lựa chọn một công việc để thực hiện \n căn cứ vào một điều kiện nào đó . Một số biến thể của cấu trúc \n này như sau : \n 1 : Nếu < điều kiện > ( đúng ) thì thực hiện < công việc > \n 2 : Nếu < điều kiện > ( đúng ) thì thực hiện < công việc 1 > , \n ngược lại ( điều kiện sai ) thì thực hiện < công việc 2 > \n 3 : Trường hợp < i > thực hiện < công việc i > \n II. 4.3 . Lặp ( Repeating ) \n Thực hiện lặp lại một công việc không hoặc nhiều lần căn cứ vào \n một điều kiện nào đó . Có hai dạng như sau : \n - Lặp xác định : là loại lặp mà khi mô tả giải thuật , số lần \n lặp của công việc đã được xác định . \n - Lặp không xác định : là loại lặp mà khi mô tả giải thuật , \n số lần lặp của công việc chưa thể xác định . Tùy thuộc vào những \n lần thực thi khác nhau của chương trình cài đặt giải thuật , số lần \n lặp có thể khác nhau . \n III. MỘT SỐ KHÁI NIỆM KHÁC \n III. 1 . Ngôn ngữ lập trình \n Ngôn ngữ lập trình là một ngôn ngữ dùng để viết chương trình \n cho máy tính . Ta có thể chia ngôn ngữ lập trình thành các loại \n sau : ngôn ngữ máy , hợp ngữ và ngôn ngữ cấp cao .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 13}}
{"text": "cho máy tính . Ta có thể chia ngôn ngữ lập trình thành các loại \n sau : ngôn ngữ máy , hợp ngữ và ngôn ngữ cấp cao . \n Ngôn ngữ máy ( machine language ) : Là các chỉ thị dưới dạng nhị \n phân , can thiệp trực tiếp vào trong các mạch điện tử . Chương \n trình được viết bằng ngôn ngữ máy thì có thể được thực hiện \n ngay không cần qua bước trung gian nào . Tuy nhiên chương trình \n viết bằng ngôn ngữ máy dễ sai sót , cồng kềnh và khó đọc , khó \n hiểu vì toàn những con số 0 và 1 . \n Hợp ngữ ( assembly language ) : Bao gồm tên các câu lệnh và quy \n tắc viết các câu lệnh đó . Tên các câu lệnh bao gồm hai phần :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 13}}
{"text": "Lập trình căn bản \n phần mã lệnh ( viết tựa tiếng Anh ) chỉ phép toán cần thực hiện và \n địa chỉ chứa toán hạng của phép toán đó . Thí dụ : \n INPUT a ; Nhập giá trị cho a từ bàn phím \n LOAD a ; Đọc giá trị a vào thanh ghi tổng A \n PRINT a ; Hiển thị giá trị của a ra màn hình . \n INPUT b \n ADD b ; Cộng giá trị của thanh ghi tổng A với giá trị b \n Trong các lệnh trên thì INPUT , LOAD , PRINT , ADD là các \n mã lệnh còn a , b là địa chỉ . Để máy thực hiện được một chương \n trình viết bằng hợp ngữ thì chương trình đó phải được dịch sang \n ngôn ngữ máy . Công cụ thực hiện việc dịch đó được gọi là \n Assembler . \n Ngôn ngữ cấp cao ( High level language ) : Ra đời và phát triển \n nhằm phản ánh cách thức người lập trình nghĩ và làm . Rất gần \n với ngôn ngữ con người ( Anh ngữ ) nhưng chính xác như ngôn \n ngữ toán học . Cùng với sự phát triển của các thế hệ máy tính , \n ngôn ngữ lập trình cấp cao cũng được phát triển rất đa dạng và \n phong phú , việc lập trình cho máy tính vì thế mà cũng có nhiều \n khuynh hướng khác nhau : lập trình cấu trúc , lập trình hướng đối \n tượng , lập trình logic , lập trình hàm ...", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 14}}
{"text": "khuynh hướng khác nhau : lập trình cấu trúc , lập trình hướng đối \n tượng , lập trình logic , lập trình hàm ... Một chương trình viết bằng \n ngôn ngữ cấp cao được gọi là chương trình nguồn ( source \n programs ) . Để máy tính \" hiểu \" và thực hiện được các lệnh trong \n chương trình nguồn thì phải có một chương trình dịch để dịch \n chuơng trình nguồn ( viết bằng ngôn ngữ cấp cao ) thành dạng \n chương trình có khả năng thực thi . \n III. 2 Chương trình dịch \n Muốn chuyển từ chương trình nguồn sang chương trình đích phải \n có chương trình dịch . Nói chung các chương trình dịch hoạt động \n theo 1 trong 2 cơ chế : \n Thông dịch ( interpreter ) : Là cách dịch từng lệnh một , dịch tới \n đâu thực hiện tới đó . Chẳng hạn ngôn ngữ LISP sử dụng trình \n thông dịch .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 14}}
{"text": "Lập trình căn bản \n Biên dịch ( compiler ) : Dịch toàn bộ chương trình nguồn thành \n chương trình đích rồi sau đó mới thực hiện . Các ngôn ngữ sử \n dụng trình biên dịch như Pascal , C. . . \n Giữa thông dịch và biên dịch có khác nhau ở chỗ : Do thông dịch \n là vừa dịch vừa thực thi chương trình còn biên dịch là dịch xong \n toàn bộ chương trình rồi mới thực thi nên chương trình viết bằng \n ngôn ngữ biên dịch thực hiện nhanh hơn chương trình viết bằng \n ngôn ngữ thông dịch . \n Một số ngôn ngữ ở đó chương trình dịch sử dụng kết hợp giữa \n thông dịch và biên dịch chẳng hạn như Java . Chương trình nguồn \n của Java được biên dịch tạo thành một chương trình đối tượng \n ( một dạng mã trung gian ) và khi thực hiện thì từng lệnh trong \n chương trình đối tượng được thông dịch thành mã máy . \n III. 3 Kiểu dữ liệu \n Các số liệu lưu trữ trong máy tính gọi là dữ liệu ( data ) . Mỗi đơn \n vị dữ liệu thuộc một kiểu dữ liệu nào đó . \n Kiểu dữ liệu là một tập hợp các giá trị có cùng một tính chất và \n tập hợp các phép toán thao tác trên các giá trị đó . Người ta chia \n kiểu dữ liệu ra làm 2 loại : kiểu dữ liệu sơ cấp và kiểu dữ liệu có \n cấu trúc . \n III. 3.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 15}}
{"text": "hợp các phép toán thao tác trên các giá trị đó . Người ta chia \n kiểu dữ liệu ra làm 2 loại : kiểu dữ liệu sơ cấp và kiểu dữ liệu có \n cấu trúc . \n III. 3.1 Kiểu dữ liệu sơ cấp \n Kiểu dữ liệu sơ cấp là kiểu dữ liệu mà giá trị của nó là đơn \n nhất . \n Thí dụ : Trong ngôn ngữ lập trình C , kiểu int gọi là kiểu sơ \n cấp vì kiểu này bao gồm các số nguyên từ - 32768 đến 32767 và \n các phép toán + , - , * , / , % … \n III. 3.2 Kiểu dữ liệu có cấu trúc \n Kiểu dữ liệu có cấu trúc là kiểu dữ liệu mà các giá trị của nó \n là sự kết hợp của các giá trị khác . \n Thí dụ : Kiểu chuỗi ký tự trong ngôn ngữ lập trình C là một \n kiểu dữ liệu có cấu trúc . \n Các ngôn ngữ lập trình đều có những kiểu dữ liệu do ngôn ngữ \n xây dựng sẵn , mà ta gọi là các kiểu chuẩn . Chẳng hạn như kiểu", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 15}}
{"text": "Lập trình căn bản \n int , char … trong C ; integer , array … trong Pascal . Ngoài ra , hầu \n hết các ngôn ngữ đều cung cấp cơ chế cho phép người lập trình \n định nghĩa kiểu của riêng mình để phục vụ cho việc viết chương \n trình . \n IV. BÀI TẬP \n Bằng ngôn ngữ tự nhiên và lưu đồ , anh ( chị ) hãy mô tả giải thuật \n cho các bài toán sau : \n 1 . Tính diện tích của 1 tam giác theo công thức Hê - rông : \n S = p * ( p  a ) * ( p  b ) * ( p  c ) \n Với a , b , c là chiều dài 3 cạnh được nhập từ bàn phím . \n p : Nửa chu vi . \n 2 . Giải phương trình bậc 2 dạng ax2 + bx + c = 0 với a , b , c là các \n số sẽ nhập từ bàn phím . \n 3 . Tính tổng bình phương của n số nguyên có dạng sau : \n S = a 2 + a 2 + … + a 2 với n và a ( i = 1 . . n ) là các số sẽ \n 1 2 n i \n nhập từ bàn phím .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 16}}
{"text": "Lập trình căn bản \n Chương 2 \n TỔNG QUAN VỀ NGÔN NGỮ LẬP \n TRÌNH C \n Các vấn đề được trình bày trong chương này : \n  Lịch sử của ngôn ngữ lập trình C. \n  Các thành phần của C. \n I. SƠ LƯỢC VỀ NGÔN NGỮ LẬP TRÌNH C \n C là ngôn ngữ lập trình cấp cao , được sử dụng rất phổ biến để lập \n trình hệ thống cùng với Assembler và phát triển các ứng dụng . \n Vào những năm cuối thập kỷ 60 đầu thập kỷ 70 của thế kỷ XX , \n Dennish Ritchie ( làm việc tại phòng thí nghiệm Bell ) đã phát \n triển ngôn ngữ lập trình C dựa trên ngôn ngữ BCPL ( do Martin \n Richards đưa ra vào năm 1967 ) và ngôn ngữ B ( do Ken \n Thompson phát triển từ ngôn ngữ BCPL vào năm 1970 khi viết \n hệ điều hành UNIX đầu tiên trên máy PDP - 7 ) và được cài đặt lần \n đầu tiên trên hệ điều hành UNIX của máy DEC PDP - 11 . \n Năm 1978 , Dennish Ritchie và B. W Kernighan đã cho xuất bản \n quyển “ Ngôn ngữ lập trình C ” và được phổ biến rộng rãi đến nay . \n Lúc ban đầu , C được thiết kế nghiệm Bell và nhanh chóng \n nhằm lập trình trong môi hội nhập vào thế giới lập \n trường của hệ điều hành trình để rồi các công ty lập \n Unix nhằm mục đích hỗ trợ trình sử dụng một cách rộng \n cho các công việc lập trình rãi .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 17}}
{"text": "hội nhập vào thế giới lập \n trường của hệ điều hành trình để rồi các công ty lập \n Unix nhằm mục đích hỗ trợ trình sử dụng một cách rộng \n cho các công việc lập trình rãi . Sau đó , các công ty sản \n phức tạp . Nhưng về sau , với xuất phần mềm lần lượt đưa \n những nhu cầu phát triển ra các phiên bản hỗ trợ cho \n ngày một tăng của công việc việc lập trình bằng ngôn ngữ \n lập trình , C đã vượt qua C và chuẩn ANSI C cũng \n khuôn khổ của phòng thí được khai sinh từ đó . \n Ngôn ngữ lập trình C là một ngôn ngữ lập trình hệ thống rất \n mạnh và rất “ mềm dẻo ” , có một thư viện gồm rất nhiều các hàm", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 17}}
{"text": "Lập trình căn bản \n ( function ) đã được tạo sẵn . Người lập trình có thể tận dụng các \n hàm này để giải quyết các bài toán mà không cần phải tạo mới . \n Hơn thế nữa , ngôn ngữ C hỗ trợ rất nhiều phép toán nên phù hợp \n cho việc giải quyết các bài toán kỹ thuật có nhiều công thức phức \n tạp . Ngoài ra , C cũng cho phép người lập trình tự định nghĩa \n thêm các kiểu dữ liệu trừu tượng khác . Tuy nhiên , điều mà người \n mới vừa học lập trình C thường gặp “ rắc rối ” là “ hơi khó hiểu ” \n do sự “ mềm dẻo ” của C. Dù vậy , C được phổ biến khá rộng rãi \n và đã trở thành một công cụ lập trình khá mạnh , được sử dụng \n như là một ngôn ngữ lập trình chủ yếu trong việc xây dựng \n những phần mềm hiện nay . \n Ngôn ngữ C có những đặc điểm cơ bản sau : \n  Tính cô đọng ( compact ) : C chỉ có 32 từ khóa chuẩn và 40 \n toán tử chuẩn , nhưng hầu hết đều được biểu diễn bằng những \n chuỗi ký tự ngắn gọn . \n  Tính cấu trúc ( structured ) : C có một tập hợp những chỉ thị \n của lập trình như cấu trúc lựa chọn , lặp … Từ đó các chương \n trình viết bằng C được tổ chức rõ ràng , dễ hiểu .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 18}}
{"text": "ọn , lặp … Từ đó các chương \n trình viết bằng C được tổ chức rõ ràng , dễ hiểu . \n  Tính tương thích ( compatible ) : C có bộ tiền xử lý và một thư \n viện chuẩn vô cùng phong phú nên khi chuyển từ máy tính này \n sang máy tính khác các chương trình viết bằng C vẫn hoàn \n toàn tương thích . \n  Tính mềm dẻo ( flexible ) : C là một ngôn ngữ rất uyển chuyển \n về cú pháp , chấp nhận nhiều cách thể hiện , có thể thu gọn kích \n thước của các mã lệnh làm chương trình chạy nhanh hơn . \n  Biên dịch ( compile ) : C cho phép biên dịch nhiều tập tin \n chương trình riêng rẽ thành các tập tin đối tượng ( object ) và \n liên kết ( link ) các đối tượng đó lại với nhau thành một chương \n trình có thể thực thi được ( executable ) thống nhất . \n II. BỘ CHỮ VIẾT TRONG C \n Bộ chữ viết trong ngôn ngữ C bao gồm những ký tự , ký hiệu sau : \n ( phân biệt chữ in hoa và in thường ) : \n  Các ký tự hoa A , B , C. . . Z \n  Các ký tự thường a , b , c ... z .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 18}}
{"text": "Lập trình căn bản \n  Các ký số 0 , 1 , 2 . \n  Các ký hiệu toán học : + , - , * , / , = , < , > , ( , ) \n  Các ký hiệu đặc biệt : : . , ; \" '   @ # $ ! ^ [ ] { } ... \n  Dấu cách hay khoảng trống . \n III. CÁC TỪ KHÓA TRONG C \n Từ khóa là các từ dành riêng ( reserved words ) của C mà người \n lập trình có thể sử dụng chúng trong chương trình tùy theo ý \n nghĩa của từng từ . Dưới đây là bảng liệt kê các từ khóa thông \n dụng của C để bạn đọc lướt qua cho có khái niệm , không nhất \n thiết phải nhớ ngay : \n break case const continue \n default do else for \n goto if return sizeof \n struct typedef while \n IV. TÊN VÀ QUY CÁCH ĐẶT TÊN \n Một chương trình nguồn C sử dụng khá nhiều tên hay còn gọi là \n định danh ( identifier ) như : tên hàm , tên biến , tên hằng … Mọi tên \n đều phải được khai báo trước khi sử dụng . \n Tên có hai loại là tên chuẩn và tên do người lập trình đặt . \n  Tên chuẩn là tên do C đặt sẵn như sin , cos , printf ... \n  Tên do người lập trình tự đặt để dùng trong chương trình \n của mình . Sử dụng bộ chữ cái , chữ số và dấu gạch dưới (   ) để \n đặt tên , nhưng phải tuân thủ quy tắc : \n o Bắt đầu bằng một chữ cái hoặc dấu gạch dưới . \n o Không có khoảng trống ở giữa tên .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 19}}
{"text": "của mình . Sử dụng bộ chữ cái , chữ số và dấu gạch dưới (   ) để \n đặt tên , nhưng phải tuân thủ quy tắc : \n o Bắt đầu bằng một chữ cái hoặc dấu gạch dưới . \n o Không có khoảng trống ở giữa tên . \n o Không được trùng với từ khóa . \n o Không cấm việc đặt tên trùng với tên chuẩn nhưng khi đó \n ý nghĩa của tên chuẩn không còn giá trị nữa . \n Thí dụ : Tên do hợp lệ : Chieu dai , Chieu Rong , Chu Vi . \n Tên không hợp lệ : Do Dai , 12A2 , …", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 19}}
{"text": "Lập trình căn bản \n Chú ý : C là ngôn ngữ phân biệt ký tự hoa và ký tự thường , vì thế \n pi và Pi là 2 tên khác nhau . \n V. CHÚ THÍCH \n Khi viết chương trình đôi lúc ta cần phải có vài lời ghi chú về 1 \n đoạn chương trình nào đó để dễ nhớ và làm sáng sủa chương \n trình . Để ý rằng phần nội dung ghi chú này phải không thuộc về \n chương trình ( khi biên dịch phần này bị bỏ qua ) . Phần ghi chú \n như vậy được gọi là chú thích . Trong ngôn ngữ lập trình C , nội \n dung chú thích phải được viết trong cặp dấu / * và * / ( nếu chú \n thích trên nhiều dòng ) , hoặc đặt sau cặp dấu / / ( nếu chú thích trên \n 1 dòng ) . \n Thí dụ : Chương trình hiển thị lên màn hình câu thông báo \n ‘ Hello World ’ . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n / * Xuat chuoi ra man hinh * / \n printf ( “ Hello World ” ) ; \n / / Cho phim bat ky \n getch ( ) ; \n } \n Ý nghĩa các dòng trong đoạn chương trình trên : \n - Các dòng \n # include < stdio . h > \n # include < conio . h > \n cho phép gộp các tập tin tiêu đề stdio . h và conio . h \n vào tập tin chương trình nguồn . Tập tin stdio . h chứa định nghĩa \n về các hàm xuất nhập chuẩn ( chẳng hạn printf ) . Tập tin conio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 20}}
{"text": "ập tin tiêu đề stdio . h và conio . h \n vào tập tin chương trình nguồn . Tập tin stdio . h chứa định nghĩa \n về các hàm xuất nhập chuẩn ( chẳng hạn printf ) . Tập tin conio . h \n chứa các hàm xuất nhập như getch ( ) . \n # include là chỉ thị hướng dẫn dịch của C , chỉ thị này thông \n báo cho chương trình dịch nạp tập tin tiêu đề stdio . h ( và conio . h ) \n vào để dịch . \n - Khối \n main ( ) \n { \n … \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 20}}
{"text": "Lập trình căn bản \n gọi là thân chương trình . Phần này bắt buộc phải có cho \n mọi chương trình C. Phần này còn được gọi là hàm main ( ) hoặc \n là điểm bắt đầu thực hiện của 1 chương trình C. \n - Dòng printf ( “ Hello World ” ) ; cho phép hiển thị giá trị \n của câu Hello World lên màn hình . \n - Dòng getch ( ) ; chờ nhận 1 ký tự từ bàn phím . Chương trình \n sẽ thực hiện tiếp tục sau khi một phím bất kỳ được ấn . \n Phần nằm trong / * * / hoặc dòng nằm sau / / là chú thích \n VI. CÁC KIỂU DỮ LIỆU SƠ CẤP CHUẨN TRONG C \n Các kiểu dữ liệu sơ cấp chuẩn trong C có thể được chia làm 2 \n dạng : kiểu số nguyên , kiểu số thực . Phần này chỉ trình bày miền \n giá trị của các kiểu , các phép toán trên các giá trị của các kiểu sẽ \n được trình bày ở các phần tiếp theo . \n VI. 1 . Kiểu số nguyên \n Kiểu số nguyên là một kiểu dữ liệu mà tập các giá trị của nó là \n tập con của tập số nguyên trong toán học . Tùy thuộc vào kích \n thước lưu trữ mà kiểu số nguyên được chia làm 3 loại : 1 byte , 2 \n bytes hay 4 bytes . Ứng với mỗi loại , người ta còn định nghĩa sẵn \n một số kiểu khác nhau . Tùy thuộc vào ứng dụng của chương trình \n mà người lập trình sẽ sử dụng 1 kiểu thích hợp . \n VI. 1.1 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 21}}
{"text": "bytes . Ứng với mỗi loại , người ta còn định nghĩa sẵn \n một số kiểu khác nhau . Tùy thuộc vào ứng dụng của chương trình \n mà người lập trình sẽ sử dụng 1 kiểu thích hợp . \n VI. 1.1 . Kiểu số nguyên 1 byte ( 8 bits )\n\n| STT | Kiểu dữ liệu | Miền giá trị (Domain) |\n| --- | --- | --- |\n| 1 | char | Từ -128 đến 127 |\n| 2 | unsigned char | Từ 0 đến 255 |\n\n\nKiểu số nguyên một byte gồm có 2 kiểu sau : \n - Kiểu char : các số nguyên thuộc kiểu char có giá trị từ - 128 \n đến 127 . \n - Kiểu unsgined char : các số nguyên thuộc kiểu unsigned \n char có giá trị từ 0 đến 255 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 21}}
{"text": "Lập trình căn bản \n Chú ý : Kiểu char còn có thể được gọi là kiểu ký tự vì C cho \n phép kiểu này được sử dụng như số nguyên và ký tự . \n VI. 1.2 . Kiểu số nguyên 2 bytes ( 16 bits ) \n Kiểu số nguyên 2 bytes gồm có 4 kiểu sau :\n\n| STT | Kiểu dữ liệu | Miền giá trị (Domain) |\n| --- | --- | --- |\n| 1 | int | Từ -32,768 đến 32,767 |\n| 2 | short | Từ -32,768 đến 32,767 |\n| 3 | unsigned int | Từ 0 đến 65,535 |\n| 4 | unsigned short | Từ 0 đến 65,535 |\n\n\nVI. 1.3 . Kiểu số nguyên 4 byte ( 32 bits ) \n Kiểu số nguyên 4 bytes hay còn gọi là số nguyên dài ( long ) \n gồm có 2 kiểu sau :\n\n| STT | Kiểu dữ liệu | Miền giá trị (Domain) |\n| --- | --- | --- |\n| 1 | long | Từ -2,147,483,648 đến 2,147,483,647 |\n| 2 | unsigned long | Từ 0 đến 4,294,967,295 |\n\n\nVI. 2 . Kiểu số thực \n Kiểu số thực là một kiểu dữ liệu mà tập các giá trị của nó \n là tập hợp con của tập các số thực trong toán học . Người ta định \n nghĩa sẵn 3 kiểu số thực với kích thước , miền giá trị và độ chính \n xác ( số chữ số thập phân ) khác nhau . Tùy thuộc vào ứng dụng \n của chương trình mà người lập trình lựa chọn 1 kiểu thích hợp để \n sử dụng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 22}}
{"text": "c nhau . Tùy thuộc vào ứng dụng \n của chương trình mà người lập trình lựa chọn 1 kiểu thích hợp để \n sử dụng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 22}}
{"text": "Lập trình căn bản\n\n| STT | Kiểu dữ liệu | Kích thước | Miền giá trị (Domain) |\n| --- | --- | --- | --- |\n| 1 | float | 4 bytes | Từ 1.2 * 10-38 đến 3.4 * 1038. Độ chính xác khoảng 7 chữ số |\n| 2 | double | 8 bytes | Từ 2.2 * 10-308 đến 3.4 * 10308. Độ chính xác khoảng 15 chữ số |\n| 3 | long double | 10 bytes | Từ 3.4 *10-4932 đến 3.4 *104932. Độ chính xác khoảng 19 chữ số. |\n\n\nNgoài ra ta còn có kiểu dữ liệu void , kiểu này mang ý nghĩa là \n kiểu rỗng không chứa giá trị gì cả . \n VII. HẰNG \n Hằng là một đại lượng mà giá trị của nó không thay đổi trong \n suốt quá trình thực hiện chương trình . Hằng có thể được đặt tên \n ( theo quy tắc đặt tên trong mục IV ) hoặc là một hằng trực tiếp . \n Hằng có thể là một chuỗi ký tự , một ký tự , một con số xác định . \n Chúng có thể được biểu diễn hay định dạng ( Format ) với nhiều \n dạng thức khác nhau . \n VII. 2.1 Hằng số thực \n Là một số thực thuộc miền giá trị của một trong 3 kiểu số \n thực được trình bày ở trên . Các giá trị số thực được biểu diễn \n theo 2 cách sau : \n  Cách 1 : Sử dụng cách viết thông thường gồm 2 phần : phần \n nguyên và phần thập phân ; mỗi phần phân cách nhau bởi dấu \n chấm ( . ) . \n Thí dụ : 0.0 ; 123.34 ; - 223.333 ; 3.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 23}}
{"text": "n \n theo 2 cách sau : \n  Cách 1 : Sử dụng cách viết thông thường gồm 2 phần : phần \n nguyên và phần thập phân ; mỗi phần phân cách nhau bởi dấu \n chấm ( . ) . \n Thí dụ : 0.0 ; 123.34 ; - 223.333 ; 3.00 ; - 56.0 \n  Cách 2 : Sử dụng cách viết theo số mũ hay số khoa học . \n Một số thực được tách làm 2 phần , cách nhau bằng ký tự e hay E \n Phần giá trị : là một số nguyên hay số thực được viết theo \n cách 1 . \n Phần mũ : là một số nguyên \n  Giá trị của số thực là : Phần giá trị nhân với 10 mũ \n phần mũ .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 23}}
{"text": "Lập trình căn bản \n Thí dụ : 1234.56 e - 3 = 1.23456 ( là số 1234.56 * 10 - 3 ) \n - 123.45 E4 = - 1234500 ( là - 123.45 * 104 ) \n VI. 2.2 Hằng số nguyên \n Một hằng số nguyên là một số nguyên thuộc miền giá trị của \n các số nguyên 1 byte , 2 bytes và 4 bytes . \n  Hằng số nguyên hệ thập phân : là số nguyên có giá trị thuộc \n kiểu số nguyên 1 byte / 2 bytes / 4 bytes và được viết như cách viết \n thông thường trong toán học ( sử dụng các ký số từ 0 đến 9 để \n biểu diễn một giá trị nguyên ) . \n Thí dụ : 123 ( một trăm hai mươi ba ) , \n - 242 ( trừ hai trăm bốn mươi hai ) . \n  Hằng số nguyên hệ bát phân : là số nguyên có giá trị thuộc \n kiểu số nguyên 1 byte / 2 bytes / 4 bytes và được biểu diễn bởi 8 \n chữ số từ 0 đến 7 , bắt đầu bằng số 0 . \n Cách biểu diễn : 0 < các ký số từ 0 đến 7 > \n Thí dụ : 0345 ( số 345 trong hệ bát phân ) \n - 020 ( số - 20 trong hệ bát phân ) \n Cách tính giá trị thập phân của số bát phân như sau : \n Số bát phân : 0d d d … d d ( d có giá trị từ 0 đến 7 ) \n n n - 1 n - 2 1 0 i \n n \n = > Giá trị thập phân =  d * 8i \n i \n i  0 \n 0345 = 229 , 020 = 16", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 24}}
{"text": "n - 2 1 0 i \n n \n = > Giá trị thập phân =  d * 8i \n i \n i  0 \n 0345 = 229 , 020 = 16", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 24}}
{"text": "Lập trình căn bản \n  Hằng số nguyên hệ thập lục phân : là số nguyên có giá trị \n thuộc kiểu số nguyên 1 byte / 2 bytes / 4 bytes và được biểu diễn \n bởi 10 chữ số từ 0 đến 9 và 6 ký tự A , B , C , D , E , F \n Ký tự Giá trị \n A 10 \n B 11 \n C 12 \n D 13 \n E 14 \n F 15 \n Cách biểu diễn : \n 0x < các ký số từ 0 đến 9 và 6 ký tự từ A đến F > \n Thí dụ : \n 0x345 ( số 345 trong hệ 16 ) \n 0x20 ( số 20 trong hệ 16 ) \n 0x2A9 ( số 2A9 trong hệ 16 ) \n Cách tính giá trị thập phân của số thập lục phân : \n Số thập lục phân : 0xd d d … d d \n n n - 1 n - 2 1 0 \n ( d từ 0 đến 9 hoặc A đến F ) \n i \n n \n = > Giá trị thập phân =  d * 16i \n i \n i  0 \n Thí dụ : 0x345 = 827 , 0x20 = 32 , 0x2A9 = 681 \n  Hằng số nguyên có định trước kiểu : Đôi khi ta muốn ghi \n các hằng số với kiểu được định trước tường minh , điều này có thể \n được thực hiện bằng cách thêm một ( một số ) ký tự vào cuối dãy \n số . \n - U ( hoặc u ) : cho kiểu unsigned int \n - L ( hoặc l ) : cho kiểu long \n - UL ( hoặc ul ) : cho kiểu unsigned long \n Thí dụ : \n 65000U : hằng số nguyên kiểu unsigned int . \n 123456789L : hằng số nguyên kiểu long", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 25}}
{"text": "ng \n Thí dụ : \n 65000U : hằng số nguyên kiểu unsigned int . \n 123456789L : hằng số nguyên kiểu long", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 25}}
{"text": "Lập trình căn bản \n VI. 2.3 . Hằng ký tự \n Hằng ký tự là một ký tự riêng biệt được viết trong cặp dấu \n nháy đơn ( ‘ ) . \n Thí dụ : ‘ a ’ , ‘ A ’ , ‘ 0 ’ , ‘ 9 ’ \n Mỗi hằng ký tự được lưu trữ đúng 1 byte trong bộ nhớ . \n Một giá trị hằng ký tự là một phần tử của 1 tập hữu hạn các \n ký tự được sắp thứ tự . Các máy tính đều sử dụng tập các ký tự \n như vậy để trao đổi thông tin với nhau qua các thiết bị xuất nhập . \n Có nhiều cách sắp xếp bộ chữ khác nhau và có một bộ chữ ( bộ \n mã ) được sử dụng phổ biến để trao đổi thông tin giữa các thiết bị , \n nhất là trên máy tính . Đó là bộ mã ASCII ( American Standard \n Code for Information Interchange ) . \n Mỗi ký tự được mã hóa đúng bằng 1 byte , vì thế bảng mã \n ASCII có thể mã hóa tới 256 ký tự ( 28 ) . Cách thức mã hóa được \n thực hiện bằng cách gán cho mỗi ký tự một giá trị số thuộc \n [ 0 ] gọi là mã ASCII của ký tự đó . \n Thí dụ : Ký tự ‘ A ’ , ‘ B ’ có mã ASCII lần lượt là 65 , 66 \n Ký tự ‘ a ’ , ‘ b ’ có mã ASCII lần lượt là 97 , 98 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 26}}
{"text": "hực tế chỉ có 128 giá trị số đầu tiên được sử dụng để mã hóa \n các ký tự thông thường , 128 giá trị tiếp theo ( từ 128 - 255 ) được \n sử dụng để mã hóa cho các ký tự riêng của 1 số ngôn ngữ , các ký \n tự toán học … \n Bảng dưới đây là bảng mã ASCII của 128 ký tự đầu tiên ( còn \n được gọi là bảng mã ASCII chuẩn ) :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 26}}
{"text": "Lập trình căn bản \n Chúng ta có thể thực hiện các phép toán số học trên 2 ký tự \n ( thực chất là thực hiện phép toán trên giá trị ASCII của chúng ) \n VI. 2.4 . Hằng chuỗi ký tự \n Hằng chuỗi ký tự là một chuỗi hay một xâu ký tự được đặt \n trong cặp dấu nháy kép ( “ ) . \n Thí dụ : “ Ngon ngu lap trinh C ” , “ Khoa CNTT - DHCT ” \n Chú ý : \n 1 . Một chuỗi không có nội dung “ ” được gọi là chuỗi rỗng . \n 2 . Khi lưu trữ trong bộ nhớ , một chuỗi được kết thúc bằng \n ký tự NULL ( ‘ \\ 0 ’ : mã ASCII là 0 ) . \n 3 . Để biểu diễn ký tự đặc biệt bên trong chuỗi ta phải thêm \n dấu \\ phía trước . \n Thí dụ : \n “ I ’ m a student ” phải viết “ I \\ ’ m a student ” \n Một số ký tự đặc biệt\n\n| Ký tự | Giá trị thập lục phân | Ký tự được hiển thị | Ý nghĩa |\n| --- | --- | --- | --- |\n| \\a | 0x07 | BEL | Phát ra tiếng chuông |\n| \\b | 0x08 | BS | Di chuyển con trỏ sang trái 1 ký tự và xóa ký tự bên trái (backspace) |\n| \\f | 0x0C | FF | Sang trang |\n| \\n | 0x0A | LF | Xuống dòng |\n| \\r | 0x0D | CR | Trở về đầu dòng |\n| \\t | 0x09 | HT | Tab theo cột (giống gõ phím Tab) |\n| \\\\ | 0x5C | \\ | Dấu \\ |\n| \\’ | 0x2C | ‘ | Dấu nháy đơn (‘) |\n| \\” | 0x22 | “ | Dấu nháy kép (“) |\n| \\? | 0x3F | ? | Đấu chấm hỏi (?) |\n|", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 27}}
{"text": "dòng |\n| \\t | 0x09 | HT | Tab theo cột (giống gõ phím Tab) |\n| \\\\ | 0x5C | \\ | Dấu \\ |\n| \\’ | 0x2C | ‘ | Dấu nháy đơn (‘) |\n| \\” | 0x22 | “ | Dấu nháy kép (“) |\n| \\? | 0x3F | ? | Đấu chấm hỏi (?) |\n| \\0 | 0x00 |  | Ký tự NULL (rỗng) |", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 27}}
{"text": "Lập trình căn bản \n VII. BIẾN \n VII. 1 . Biến \n Biến là một đại lượng được người lập trình định nghĩa và được \n đặt tên thông qua việc khai báo biến . Biến dùng để lưu trữ giá trị \n dữ liệu trong quá trình thực hiện chương trình và giá trị của biến \n có thể bị thay đổi trong quá trình này . Việc đặt tên biến phải tuân \n theo quy tắc đặt tên trong mục IV. \n Khi khai báo biến ta phải xác định kiểu cho nó . Và khi đó , giá trị \n của biến phải thuộc miền giá trị của kiểu . \n VII. 1.1 . Cú pháp khai báo biến : \n < Kiểu dữ liệu > Danh sách các tên biến cách nhau \n bởi dấu phẩy ; \n Thí dụ : \n int a , b , c ; / / Ba biến a , b , c có kiểu int \n long n ; / / Biến n có kiểu long \n float nua chu vi ; / * Biến nua chu vi \n có kiểu float * / \n double dien tich ; / * Biến dien tich có \n kiểu double * / \n Lưu ý : Phải có dấu chấm phẩy ở cuối phần khai báo biến . \n VII. 1.2 . Vị trí khai báo biến trong C \n Trong ngôn ngữ lập trình C , ta phải khai báo biến đúng vị \n trí . Nếu khai báo ( đặt các biến ) không đúng vị trí sẽ dẫn đến \n những sai sót ngoài ý muốn mà người lập trình không lường \n trước ( hiệu ứng lề ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 28}}
{"text": "không đúng vị trí sẽ dẫn đến \n những sai sót ngoài ý muốn mà người lập trình không lường \n trước ( hiệu ứng lề ) . Về cơ bản , ta có 2 cách đặt vị trí của biến \n như sau : \n a ) Khai báo biến ngoài : Các biến này được đặt bên ngoài \n tất cả các hàm và nó có tác dụng hay ảnh hưởng đến toàn bộ \n chương trình ( còn gọi là biến toàn cục ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 28}}
{"text": "Lập trình căn bản \n Thí dụ : \n int i ; / * Bien ben ngoai * / \n float pi ; / * Bien ben ngoai * / \n main ( ) \n { … \n } \n b ) Khai báo biến trong : Các biến được đặt ở bên trong hàm , \n hay trong một khối lệnh . Các biến này chỉ có tác dụng hay ảnh \n hưởng đến hàm hay khối lệnh chứa nó . Vì thế chúng còn được \n gọi là các biến cục bộ của hàm hay khối lệnh . Vị trí khai báo của \n các biến này là ở đầu mỗi khối lệnh . \n Thí dụ 1 : \n # include < stdio . h > \n # include < conio . h > \n int bienngoai ; / * khai bao bien ngoai * / \n main ( ) \n { \n int j , i ; / / khai bao bien cuc bo trong ham main \n i = 1 ; j = 2 ; \n bienngoai = 3 ; \n printf ( \" \\ n Gia7 tri cua i la % d \" , i ) ; \n / * % d : In một số nguyên * / \n printf ( \" \\ n Gia tri cua j la % d \" , j ) ; \n printf ( \" \\ n Gia tri cua bienngoai la \n % d \" , bienngoai ) ; \n getch ( ) ; \n } \n Thí dụ 2 : \n # include < stdio . h > \n # include < conio . h > \n main ( ) \n { int i , j ; / * Bien cuc bo * / \n i = 4 ; j = 5 ; \n printf ( \" \\ n Gia tri cua i la % d \" , i ) ; \n printf ( \" \\ n Gia tri cua j la % d \" , j ) ; \n if ( j > i ) \n { \n int hieu = j - i ; / * Bien cuc bo * / \n printf ( \" \\ n j tru i la % d \" , hieu ) ; \n } \n else", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 29}}
{"text": "tri cua i la % d \" , i ) ; \n printf ( \" \\ n Gia tri cua j la % d \" , j ) ; \n if ( j > i ) \n { \n int hieu = j - i ; / * Bien cuc bo * / \n printf ( \" \\ n j tru i la % d \" , hieu ) ; \n } \n else", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 29}}
{"text": "Lập trình căn bản \n { \n int hieu = i - j ; / * Bien cuc bo * / \n printf ( \" \\ n i tru j la % d \" , hieu ) ; \n } \n getch ( ) ; \n } \n VIII. BIỂU THỨC \n Biểu thức là một sự kết hợp giữa các toán tử ( operator ) và các \n toán hạng ( operand ) theo đúng một trật tự nhất định . \n Mỗi toán hạng có thể là một hằng , một biến , một hàm hoặc một \n biểu thức khác . \n Mỗi biểu thức có một giá trị . Giá trị của 1 biểu thức có được bằng \n cách áp dụng toán tử lên các toán hạng . \n Trong một biểu thức có nhiều toán tử có cùng độ ưu tiên thì thứ \n tự thực hiện các phép toán là từ trái sang phải ( quy tắc kết hợp \n trái ) . \n Trong một biểu thức có nhiều toán tử có độ ưu tiên khác nhau thì \n toán tử nào có độ ưu tiên cao hơn sẽ được thực hiện trước ( quy \n tắc ưu tiên ) . \n Nếu cần thay đổi thứ tự thực hiện các toán tử theo 2 quy tắc trên , \n ta dùng cặp dấu ngoặc đơn ( ) để chỉ định toán tử nào sẽ được \n thực hiện trước . \n Thí dụ : Biểu thức nghiệm của phương trình bậc hai : \n ( - b + sqrt ( Delta ) ) / ( 2 * a ) \n Trong đó \n - 2 là hằng ; a , b , Delta là biến . \n - sqrt : hàm tính căn bậc 2 \n - + , * , / , - là các toán tử \n - Biểu thức có sử dụng các dấu ngoặc đơn để tăng độ ưu \n tiên .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 30}}
{"text": ") / ( 2 * a ) \n Trong đó \n - 2 là hằng ; a , b , Delta là biến . \n - sqrt : hàm tính căn bậc 2 \n - + , * , / , - là các toán tử \n - Biểu thức có sử dụng các dấu ngoặc đơn để tăng độ ưu \n tiên . \n VIII. 1 Các toán tử số học \n Các toán tử 2 ngôi : gồm có + , - , * , / , % .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 30}}
{"text": "Lập trình căn bản\n\n| Toán tử | Miền giá trị của toán hạng | Miền giá trị của kết quả | Ý nghĩa |\n| --- | --- | --- | --- |\n| + | Nguyên, Thực | Nguyên, Thực | Cộng 2 số |\n| - | Nguyên, Thực | Nguyên, Thực | Trừ 2 số |\n| * | Nguyên, Thực | Nguyên, Thực | Nhân 2 số |\n| / | Nguyên | Nguyên | Chia lấy phần nguyên |\n| % | Thực | Thực | Chia 2 số, kết quả là một số thực |\n\n\nTăng và giảm ( + + & - - ) \n Đây là 2 toán tử 1 ngôi để làm tăng ( + + ) hoặc giảm ( - - ) giá \n trị của biến . \n Chẳng hạn : \n + + x giống như x = x + 1 \n x - - giống như x = x – 1 \n Cả 2 toán tử tăng và giảm đều có thể tiền tố ( đặt trước ) \n hay hậu tố ( đặt sau ) toán hạng . Thí dụ : x = x + 1 có thể viết \n x + + ( hay + + x ) \n Tuy nhiên giữa tiền tố và hậu tố có sự khác biệt khi sử \n dụng trong 1 biểu thức . \n Đối với toán tử + + , cả 2 trường hợp đều làm tăng giá trị \n của biến . Nhưng + + x sẽ làm tăng giá trị của x lên 1 đơn vị trước \n khi giá trị của x được sử dụng trong khi x + + sẽ sử dụng giá trị \n của x trước , sau đó x mới tăng giá trị lên 1 đơn vị . \n Thí dụ : \n x = 10 \n y = + + x / / y = 11 \n Tuy nhiên : \n x = 10 \n y = x + + / / y = 10 \n Tương tự đối với toán tử - - .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 31}}
{"text": "c , sau đó x mới tăng giá trị lên 1 đơn vị . \n Thí dụ : \n x = 10 \n y = + + x / / y = 11 \n Tuy nhiên : \n x = 10 \n y = x + + / / y = 10 \n Tương tự đối với toán tử - - . \n Thứ tự ưu tiên của các toán tử số học : \n + + - - sau đó là * / % rồi mới đến + -", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 31}}
{"text": "Lập trình căn bản \n VIII. 2 Các toán tử quan hệ và các toán tử Logic \n Trong C , mọi giá trị khác 0 được xem là đúng còn 0 là sai . \n Các biểu thức sử dụng các toán tử quan hệ và Logic gọi là các \n biểu thức logic và giá trị của 1 biểu thức logic là 1 hoặc 0 . \n Các toán tử quan hệ\n\n| Toán tử | Miền giá trị của toán hạng | Miền giá trị của kết quả | Ý nghĩa |\n| --- | --- | --- | --- |\n| > | Số, ký tự | 0, 1 | Lớn hơn |\n| >= | Số, ký tự | 0, 1 | Lớn hơn hoặc bằng |\n| < | Số, ký tự | 0, 1 | Nhỏ hơn |\n| <= | Số, ký tự | 0, 1 | Nhỏ hơn hoặc bằng |\n| == | Số, ký tự | 0, 1 | Bằng |\n| != | Số, ký tự | 0, 1 | Khác |\n\n\nCác toán tử logic\n\n| Toán tử | Miền giá trị của toán hạng | Miền giá trị của kết quả | Ý nghĩa |\n| --- | --- | --- | --- |\n| && | 0, 1 | 0, 1 | AND |\n| ||| | 0, 1 | 0, 1 | OR |\n| ! | 0, 1 | 0, 1 | NOT |\n\n\nBảng chân trị cho các toán tử Logic :\n\n| p | q | p&&q | p||q | !p |\n| --- | --- | --- | --- | --- |\n| 0 | 0 | 0 | 0 | 1 |\n| 0 | 1 | 0 | 1 | 1 |\n| 1 | 0 | 0 | 1 | 0 |\n| 1 | 1 | 1 | 1 | 0 |\n\n\nCác toán tử quan hệ và Logic đều có độ ưu tiên thấp hơn \n các toán tử số học . Do đó một biểu thức như : 10 > 1 + 12 sẽ được \n xem là 10 > ( 1 + 12 ) và kết quả là sai ( 0 ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 32}}
{"text": "| 1 | 0 |\n\n\nCác toán tử quan hệ và Logic đều có độ ưu tiên thấp hơn \n các toán tử số học . Do đó một biểu thức như : 10 > 1 + 12 sẽ được \n xem là 10 > ( 1 + 12 ) và kết quả là sai ( 0 ) . \n Ta có thể kết hợp vài toán tử lại với nhau thành biểu thức \n như sau : \n 10 > 5 & & ! ( 10 < 9 ) | | 3 < = 4 Kết quả là đúng", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 32}}
{"text": "Lập trình căn bản \n Thứ tự ưu tiên của các toán tử quan hệ và Logic \n Cao nhất : ! \n > > = < < = \n = = ! = \n & & \n Thấp nhất : | | \n VIII. 3 Các toán tử thao tác bit \n Đây là các toán tử cho phép thao tác trên từng bit nhị phân \n của các toán hạng là các số nguyên .\n\n| Toán tử | Ý nghĩa |\n| --- | --- |\n| & | AND theo từng bit |\n| | | OR theo từng bit |\n| ^ | XOR theo từng bit |\n| ~ | Đảo bit |\n\n\nThí dụ : \n - Với số nguyên 3 , dạng nhị phân là : \n 3 = 0000 0000 0000 0011 \n ~ 3 = 1111 1111 1111 1100 \n - 3 & 5 sẽ có kết quả : \n 0000 0000 0000 0011 3 \n 0000 0000 0000 0110 6 \n Kết quả : 0000 0000 0000 0010 4 \n Bảng chân trị của toán tử ^ ( XOR )\n\n| p | q | p^q |\n| --- | --- | --- |\n| 0 | 0 | 0 |\n| 0 | 1 | 1 |\n| 1 | 0 | 1 |\n| 1 | 1 | 0 |", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 33}}
{"text": "Lập trình căn bản \n Phép toán dịch trái và dịch phải : \n Phép tính nhân một số nguyên với một số là lũy thừa của 2 \n có thể thực hiện nhanh hơn nếu dùng >> ( dịch phải ) hoặc < < \n ( dịch trái ) . \n - N < < M : dịch sang trái số nguyên N đi M bit , tương \n đương N * 2M . \n - N >> M : dịch sang phải số nguyên N đi M bit , tương \n đương N / 2M . \n Thí dụ : 4 < < 3 , kết quả là 32 ( 4 * 23 ) . \n VIII. 4 Toán tử ? cùng với : \n C có một toán tử rất mạnh và trong 1 số trường hợp có thể \n dùng để thay thế cho các câu lệnh của If - Then - Else . Cú pháp của \n việc sử dụng toán tử ? là : \n E1 ? E2 : E3 \n Trong đó E1 , E2 , E3 là các biểu thức . \n Ý nghĩa : Trước tiên E1 được ước lượng , nếu đúng E2 được \n ước lượng và nó trở thành giá trị của biểu thức ; nếu E1 sai , E2 \n được ước lượng và trở thành giá trị của biểu thức . \n Thí dụ : \n X = 10 \n Y = X > 9 ? 100 : 200 \n Thì Y được gán giá trị 100 , nếu X nhỏ hơn 9 thì Y \n sẽ nhận giá trị là 200 . Đoạn mã này tương đương cấu trúc if \n như sau : \n X = 10 \n if ( X < 9 ) Y = 100 \n else Y = 200 \n VIII. 5 Toán tử con trỏ & và * \n Một con trỏ là địa chỉ trong bộ nhớ của một biến .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 34}}
{"text": "X = 10 \n if ( X < 9 ) Y = 100 \n else Y = 200 \n VIII. 5 Toán tử con trỏ & và * \n Một con trỏ là địa chỉ trong bộ nhớ của một biến . Một biến \n con trỏ là một biến được khai báo riêng để chứa một con trỏ đến \n một đối tượng của kiểu đã chỉ ra nó . Ta sẽ tìm hiểu kỹ hơn về con", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 34}}
{"text": "Lập trình căn bản \n trỏ trong chương về con trỏ . Phần này chỉ đề cập ngắn gọn đến \n hai toán tử thường được sử dụng để thao tác với các con trỏ . \n Toán tử thứ nhất là & , là một toán tử trả về địa chỉ bộ nhớ của \n 1 biến . \n Thí dụ : \n m = & count \n Đặt vào biến m địa chỉ bộ nhớ của biến count . \n Chẳng hạn , biến count ở vị trí bộ nhớ 2000 , giả sử \n count có giá trị là 100 . Sau câu lệnh trên m sẽ nhận giá trị \n 2000 . \n Toán tử thứ hai là * , là một bổ sung cho & ; đây là một toán tử \n trả về giá trị của biến được cấp phát tại địa chỉ theo sau đó . \n Thí dụ : \n q = * m \n Sẽ đặt giá trị của count vào q . Bây giờ q sẽ có giá \n trị là 100 vì 100 được lưu trữ tại địa chỉ 2000 . \n VIII. 6 Toán tử dấu phẩy , \n Toán tử dấu , được sử dụng để kết hợp các biểu thức lại với \n nhau . Bên trái của toán tử dấu , luôn được xem là kiểu void . Điều \n đó có nghĩa là biểu thức bên phải trở thành giá trị của tổng các \n biểu thức được phân cách bởi dấu phẩy . \n Thí dụ : x = ( y = 3 , y + 1 ) ; \n Trước hết gán 3 cho y rồi gán 4 cho x . Cặp dấu ngoặc \n đơn là cần thiết vì toán tử dấu , có độ ưu tiên thấp hơn toán tử \n gán . \n VIII.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 35}}
{"text": "hết gán 3 cho y rồi gán 4 cho x . Cặp dấu ngoặc \n đơn là cần thiết vì toán tử dấu , có độ ưu tiên thấp hơn toán tử \n gán . \n VIII. 7 Xem các dấu ngoặc đơn và cặp dấu ngoặc vuông là toán \n tử \n Trong C , cặp dấu ngoặc đơn là toán tử và chúng được dùng để \n tăng độ ưu tiên của các biểu thức bên trong nó .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 35}}
{"text": "Lập trình căn bản \n Các cặp dấu ngoặc vuông thực hiện thao tác truy xuất phần tử \n trong mảng ( sẽ được trình bày rõ ràng hơn trong chương Mảng ) . \n VIII. 8 Tổng kết về độ ưu tiên\n\n| Cao nhất | () [] |\n| --- | --- |\n|  | ! ~ ++ -- (Kiểu) * & |\n|  | * / % |\n|  | + - |\n|  | << >> |\n|  | < <= > >= |\n|  | & |\n|  | ^ |\n|  | | |\n|  | && |\n|  | || |\n|  | ?: |\n|  | = += -= *= /= |\n| Thấp nhất | , |\n\n\nVIII. 9 Phép gán mở rộng trong C \n Trong một số trường hợp , ta có thể viết tắt như sau : x + = 10 . \n Thực chất của cách viết này là tương đương với cách viết x = x + \n 10 . \n Cách viết như trong thí dụ vừa nêu có thể thực hiện trên tất cả \n các toán tử hai ngôi của C. Tổng quát : \n ( Biến ) = ( Biến ) ( Toán tử ) ( Biểu thức ) \n có thể được viết : \n ( Biến ) ( Toán tử ) = Biểu thức ) \n IX. CẤU TRÚC CỦA 1 CHƯƠNG TRÌNH C \n IX. 1 . Tiền xử lý và biên dịch \n Trong C , việc dịch một tập tin nguồn được tiến hành trên hai \n bước hoàn toàn độc lập với nhau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 36}}
{"text": "Lập trình căn bản \n - Tiền xử lý . \n - Biên dịch . \n Hai bước này trong phần lớn thời gian được nối tiếp với nhau \n một cách tự động theo cách thức mà ta có ấn tượng rằng nó đã \n được thực hiện như là một xử lý duy nhất . Nói chung , ta thường \n nói đến việc tồn tại của một bộ tiền xử lý ( preprocessor ) nhằm \n chỉ rõ chương trình thực hiện việc xử lý trước . Ngược lại , các \n thuật ngữ trình biên dịch hay sự biên dịch vẫn còn nhập nhằng \n bởi vì nó chỉ ra khi thì toàn bộ hai giai đoạn , khi thì lại là giai \n đoạn thứ hai . \n Bước tiền xử lý tương ứng với việc cập nhật trong văn bản của \n chương trình nguồn , chủ yếu dựa trên việc diễn giải các mã lệnh \n rất đặc biệt gọi là các chỉ thị dẫn hướng của bộ tiền xử lý \n ( destination directive of preprocessor ) ; các chỉ thị này được nhận \n biết bởi chúng bắt đầu bằng ký hiệu ( symbol ) # . \n Hai chỉ thị quan trọng nhất là : \n - Chỉ thị sự gộp vào các tập tin nguồn khác : # include \n - Chỉ thị việc định nghĩa các macros hoặc ký hiệu : # define \n Chỉ thị đầu tiên được sử dụng trước hết là nhằm gộp vào \n nội dung của các tập tin cần có ( tập tin thư viện ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 37}}
{"text": "ine \n Chỉ thị đầu tiên được sử dụng trước hết là nhằm gộp vào \n nội dung của các tập tin cần có ( tập tin thư viện ) . Chỉ thị này \n thường sử dụng vì bởi các hàm của thư viện chuẩn của C được \n định nghĩa trong các tập tin thư viện ; do đó , muốn sử dụng các \n hàm này , tập tin thư viện định nghĩa chúng phải được gộp vào . \n Thí dụ : # include < stdio . h > \n Chỉ thị thứ hai rất hay được sử dụng trong các tập tin thư \n viện ( header file ) đã được định nghĩa trước đó và thường được \n khai thác bởi các lập trình viên trong việc định nghĩa các ký hiệu \n như là : \n # define NB COUPS MAX 100 \n # define SIZE 25", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 37}}
{"text": "Lập trình căn bản \n IX. 2 Cấu trúc một chương trình C \n Một chương trình C bao gồm các phần như : Các chỉ thị \n tiền xử lý , khai báo biến ngoài , các hàm tự tạo , chương trình \n chính ( hàm main ) . \n Cấu trúc có thể như sau :\n\n|  | Các chỉ thị tiền xử lý (Preprocessor directives) #include <Tên tập tin thư viện> #define …. Thí dụ: #include<stdio.h> #define MAXINT 32767 |\n| --- | --- |\n| Các chỉ thị tiền xử lý (Preprocessor directives) #include <Tên tập tin thư viện> #define …. Thí dụ: #include<stdio.h> #define MAXINT 32767 | Các chỉ thị tiền xử lý (Preprocessor directives) #include <Tên tập tin thư viện> #define …. Thí dụ: #include<stdio.h> #define MAXINT 32767 |\n\n\n\n|  | Định nghĩa kiểu dữ liệu (phần này không bắt buộc): dùng để đặt tên lại cho một kiểu dữ liệu nào đó để gợi nhớ hay đặt 1 kiểu dữ liệu cho riêng mình dựa trên các kiểu dữ liệu đã có. Cú pháp: typedef <Tên kiểu cũ> <Tên kiểu mới>; Thí dụ: typedef int SoNguyen; // Kiểu SoNguyen là kiểu int |\n| --- | --- |\n| Định nghĩa kiểu dữ liệu (phần này không bắt buộc): dùng để đặt tên lại cho một kiểu dữ liệu nào đó để gợi nhớ hay đặt 1 kiểu dữ liệu cho riêng mình dựa trên các kiểu dữ liệu đã có.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 38}}
{"text": "u dữ liệu (phần này không bắt buộc): dùng để đặt tên lại cho một kiểu dữ liệu nào đó để gợi nhớ hay đặt 1 kiểu dữ liệu cho riêng mình dựa trên các kiểu dữ liệu đã có. Cú pháp: typedef <Tên kiểu cũ> <Tên kiểu mới>; Thí dụ: typedef int SoNguyen; // Kiểu SoNguyen là kiểu int | Định nghĩa kiểu dữ liệu (phần này không bắt buộc): dùng để đặt tên lại cho một kiểu dữ liệu nào đó để gợi nhớ hay đặt 1 kiểu dữ liệu cho riêng mình dựa trên các kiểu dữ liệu đã có. Cú pháp: typedef <Tên kiểu cũ> <Tên kiểu mới>; Thí dụ: typedef int SoNguyen; // Kiểu SoNguyen là kiểu int |\n\n\n\n|  | Khai báo các prototype (tên hàm, các tham số, kiểu kết quả trả về,… của các hàm sẽ cài đặt trong phần sau, phần này không bắt buộc): phần này chỉ là các khai báo đầu hàm, không phải là phần định nghĩa hàm. |  |\n| --- | --- | --- |\n|  | Khai báo các prototype (tên hàm, các tham số, kiểu kết quả trả về,… của các hàm sẽ cài đặt trong phần sau, phần này không bắt buộc): phần này chỉ là các khai báo đầu hàm, không phải là phần định nghĩa hàm. |  |\n| Khai báo các biến ngoài (các biến toàn cục) phần này không bắt buộc: phần này khai báo các biến toàn cục được sử dụng trong cả chương trình.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 38}}
{"text": "nh nghĩa hàm. |  |\n| Khai báo các biến ngoài (các biến toàn cục) phần này không bắt buộc: phần này khai báo các biến toàn cục được sử dụng trong cả chương trình. | Khai báo các biến ngoài (các biến toàn cục) phần này không bắt buộc: phần này khai báo các biến toàn cục được sử dụng trong cả chương trình. |  |\n\n\n\n|  | Chương trình chính (hàm main), phần này bắt buộc phải có main() { Các khai báo cục bộ trong hàm main: Các khai báo này chỉ tồn tại trong hàm mà thôi, có thể là khai báo biến hay khai báo kiểu. Các câu lệnh dùng để định nghĩa hàm main } |\n| --- | --- |\n| Chương trình chính (hàm main), phần này bắt buộc phải có main() { Các khai báo cục bộ trong hàm main: Các khai báo này chỉ tồn tại trong hàm mà thôi, có thể là khai báo biến hay khai báo kiểu. Các câu lệnh dùng để định nghĩa hàm main } | Chương trình chính (hàm main), phần này bắt buộc phải có main() { Các khai báo cục bộ trong hàm main: Các khai báo này chỉ tồn tại trong hàm mà thôi, có thể là khai báo biến hay khai báo kiểu. Các câu lệnh dùng để định nghĩa hàm main } |", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 38}}
{"text": "u. Các câu lệnh dùng để định nghĩa hàm main } |", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 38}}
{"text": "|  | ập trình căn bản Cài đặt các hàm <Kiểu dữ liệu trả về> <Tên hàm>( các tham số) { Các khai báo cục bộ trong hàm. Các câu lệnh dùng để định nghĩa hàm [return <kết quả trả về>;] } … |\n| --- | --- |\n| Cài đặt các hàm <Kiểu dữ liệu trả về> <Tên hàm>( các tham số) { Các khai báo cục bộ trong hàm. Các câu lệnh dùng để định nghĩa hàm [return <kết quả trả về>;] } … | Cài đặt các hàm <Kiểu dữ liệu trả về> <Tên hàm>( các tham số) { Các khai báo cục bộ trong hàm. Các câu lệnh dùng để định nghĩa hàm [return <kết quả trả về>;] } … |\n\n\nMột chương trình C được thực thi từ hàm main ( thông thường là \n từ câu lệnh đầu tiên đến câu lệnh cuối cùng ) . \n IX. 3 Cú pháp khai báo các phần bên trong môt chương trình \n C \n IX. 3.1 . Chỉ thị # include để sử dụng tập tin thư viện \n Cú pháp : \n # include < Tên tập tin > \n hay # include “ Tên đường dẫn ” \n Thí dụ : # include < stdio . h > \n Nếu ta dùng # include ” Tên đường dẫn ” thì ta phải chỉ rõ \n tên ở đâu , tên thư mục và tập tin thư viện . \n Thí dụ : # include ” C : \\ \\ TC \\ \\ math . h ” \n Trong trường hợp tập tin thư viện nằm trong thư mục hiện \n hành thì ta chỉ cần đưa tên tập tin thư viện . Thí dụ : \n # include ” math . h ” . \n IXI. 3.2 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 39}}
{"text": "include ” C : \\ \\ TC \\ \\ math . h ” \n Trong trường hợp tập tin thư viện nằm trong thư mục hiện \n hành thì ta chỉ cần đưa tên tập tin thư viện . Thí dụ : \n # include ” math . h ” . \n IXI. 3.2 . Chỉ thị # define để định nghĩa một tên \n Chỉ thị này có cú pháp dạng đơn giản như sau : \n # define < Tên > < Giá trị > \n Ví dụ : \n # define MAXINT 32767", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 39}}
{"text": "Lập trình căn bản \n Trong thí dụ trên , chỉ thị define định nghĩa một tên \n MAXINT ; tên này có thể sử dụng như một hằng nguyên có giá trị \n là 32767 . \n IX. 3.3 Khai báo các prototype của hàm \n Cú pháp : \n < Kiểu kết quả trả về > Tên hàm ( danh sách đối số ) \n Thí dụ : \n long giaithua ( int n ) ; \n double x mu y ( float x , float y ) ; \n IX. 3.4 . Cấu trúc của hàm main \n Hàm main chính là chương trình chính , gồm các khai báo , các \n lệnh xử lý , các lời gọi các hàm khác . \n Cú pháp : \n main ( đối số ) \n { \n Các khai báo và các câu lệnh định nghĩa hàm \n } \n Thí dụ : \n main ( ) \n { \n int a = 5 , b = 6 , c ; \n float x = 3.5 , y = 4.5 , z ; \n printf ( “ Day la chuong trinh chinh ” ) ; \n c = a + b ; \n printf ( “ \\ n % d + % d = % d ” , a , b , c ) ; \n z = x + y ; \n printf ( “ \\ n % f + % f = % f ” , x , y , z ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 40}}
{"text": "Lập trình căn bản \n Chương 3 \n CÁC CÂU LỆNH ĐƠN TRONG C \n Các vấn đề được trình bày trong chương này : \n  Khái niệm và phân loại câu lệnh \n  Các lệnh đơn trong C : \n o Gán . \n o Nhập dữ liệu từ bàn phím . \n o Hiển thị kết quả lên màn hình . \n I. CÂU LỆNH \n I. 1 . Khái niệm câu lệnh \n Một câu lệnh ( statement ) xác định một công việc mà chương \n trình phải thực hiện để xử lý dữ liệu đã được mô tả và khai báo . \n Trong C , các câu lệnh được ngăn cách với nhau bởi dấu chấm \n phẩy ( ; ) . \n I. 2 . Phân loại \n Có hai loại câu lệnh : lệnh đơn và lệnh có cấu trúc . \n Lệnh đơn là một lệnh không chứa các lệnh khác . Các lệnh \n đơn gồm : lệnh gán , các câu lệnh nhập xuất dữ liệu … \n Lệnh có cấu trúc là lệnh trong đó chứa các lệnh khác . \n Lệnh có cấu trúc bao gồm : cấu trúc điều kiện rẽ nhánh , cấu trúc \n điều kiện lựa chọn , cấu trúc lặp và cấu trúc lệnh hợp thành . Lệnh \n hợp thành ( khối lệnh ) là một nhóm bao gồm nhiều khai báo biến \n và các lệnh được gom vào trong cặp dấu { } . \n II. CÁC LỆNH ĐƠN \n II. 1 . Lệnh gán \n Lệnh gán ( assignment statement ) dùng để gán giá trị của một \n biểu thức cho một biến . \n Cú pháp : < Tên biến > = < biểu thức >", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 41}}
{"text": "LỆNH ĐƠN \n II. 1 . Lệnh gán \n Lệnh gán ( assignment statement ) dùng để gán giá trị của một \n biểu thức cho một biến . \n Cú pháp : < Tên biến > = < biểu thức >", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 41}}
{"text": "Lập trình căn bản \n Thí dụ : \n main ( ) { \n float Dai , Rong , Chu Vi ; \n Dai = 10.0 ; / / Gán 10.0 cho biến Dai \n Rong = 5.0 ; / / Gán 5.0 cho biến Rong \n / / Tính chu vi hình chữ nhật \n Chu Vi = 2 * ( Dai + Rong ) ; \n } \n Nguyên tắc khi dùng lệnh gán là kiểu của biến và kiểu của biểu thức \n phải giống nhau , gọi là có sự tương thích giữa các kiểu dữ liệu . Chẳng \n hạn thí dụ sau cho thấy một sự không tương thích về kiểu : \n main ( ) { \n int x ; \n x = 10 ; / / Gán hằng số 10 cho biến x \n y = “ Xin chao ” ; \n / / y có kiểu int , còn “ Xin chao ” có kiểu char * \n } \n Khi biên dịch chương trình này , C sẽ báo lỗi \" Cannot \n convert ‘ char * ’ to ‘ int ’ \" tức là C không thể tự động chuyển đổi \n kiểu từ char * ( chuỗi ký tự ) sang int . \n Tuy nhiên trong đa số trường hợp sự tự động biến đổi kiểu \n để sự tương thích về kiểu sẽ được thực hiện . Thí dụ : \n main ( ) { \n float Dai , Rong , Chu Vi ; \n Dai = 10 ; / / Gán 10 cho biến Dai \n Rong = 5 ; / / Gán 5 cho biến Rong \n / / Tính chu vi hình chữ nhật \n Chu Vi = 2 * ( Dai + Rong ) ; \n } \n Trong thí dụ trên , 10 là 1 hằng int được gán cho biến Dai \n kiểu float ( tương tự 5 được gán cho Rong ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 42}}
{"text": "chữ nhật \n Chu Vi = 2 * ( Dai + Rong ) ; \n } \n Trong thí dụ trên , 10 là 1 hằng int được gán cho biến Dai \n kiểu float ( tương tự 5 được gán cho Rong ) . Ở đây có một sự \n chuyển đổi kiểu tự động từ int sang float để cuối cùng biến Dai \n ( Rong ) lưu những giá trị là các số float .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 42}}
{"text": "Lập trình căn bản \n Trong nhiều trường hợp để tạo ra sự tương thích về kiểu , \n ta phải sử dụng đến cách thức chuyển đổi kiểu một cách tường \n minh . Cú pháp của phép toán này như sau : \n ( Tên kiểu ) < Biểu thức > \n  Ý nghĩa : Chuyển đổi kiểu của < Biểu thức > \n thành kiểu mới < Tên kiểu > . Chẳng hạn như : \n float f ; \n f = ( float ) 10 / 4 ; / / f lúc này là 2.5 \n Chú ý : \n - Khi một biểu thức được gán cho một biến thì giá trị của \n nó sẽ thay thế giá trị cũ mà biến đã lưu giữ trước đó . \n - Trong câu lệnh gán , dấu = là một toán tử ; do đó nó có thể \n được sử dụng là một thành phần của biểu thức . Trong trường hợp \n này giá trị của biểu thức gán chính là giá trị của biến . \n Thí dụ : \n int x , y ; \n y = ( x = 3 , x + 1 ) ; / / y lúc này là 4 \n - Ta có thể gán trị cho biến lúc biến được khai báo theo \n cách thức sau : \n < Tên kiểu > < Tên biến > = < Biểu thức > ; \n Thí dụ : float Dai = 10.0 , Rong = 5.0 ; \n II. 2 . Nhập giá trị từ bàn phím cho biến ( hàm scanf ( ) ) \n Thực chất đây là việc đọc dữ liệu từ bàn phím và gán cho các \n biến trong chương trình khi chương trình thực thi .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 43}}
{"text": "là việc đọc dữ liệu từ bàn phím và gán cho các \n biến trong chương trình khi chương trình thực thi . Để thực hiện \n được việc này , ngôn ngữ C hỗ trợ hàm scanf được định nghĩa \n trong thư viện stdio . h . \n Cú pháp : \n scanf ( “ Chuỗi định dạng ” , Địa chỉ của các biến ) ; \n Giải thích : \n - Chuỗi định dạng : dùng để quy định kiểu dữ liệu , cách \n biểu diễn , độ rộng , số chữ số thập phân ... Bảng dưới đây là một \n số định dạng khi nhập biến thuộc kiểu số nguyên , số thực , ký \n tự , … :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 43}}
{"text": "Lập trình căn bản\n\n| Định dạng |  | Ý nghĩa |\n| --- | --- | --- |\n| %[số ký số]d |  | Nhập số nguyên có tối đa <số ký số> |\n| %[số ký số] f |  | Nhập số thực có tối đa <số ký số> tính cả dấu chấm |\n| %c |  | Nhập một ký tự |\n| Thí dụ: |  |  |\n| %d | Nhập số nguyên |  |\n| %4d | Nhập số nguyên tối đa 4 ký số, nếu nhập nhiều hơn 4 ký số thì chỉ nhận được 4 ký số đầu tiên |  |\n| %f | Nhập số thực |  |\n| %6f | Nhập số thực tối đa 6 ký số (tính luôn dấu chấm thập phân), nếu nhập nhiều hơn 6 ký số thì chỉ nhận được 6 ký số đầu tiên (hoặc 5 ký số với dấu chấm) |  |\n\n\n- Địa chỉ của các biến : là địa chỉ của các biến mà ta cần \n nhập giá trị cho biến đó . Thông thường các địa chỉ này được viết \n như sau : & < tên biến > . \n Thí dụ : \n / / Doc gia tri cho bien1 co kieu nguyen \n scanf ( “ % d ” , & bien1 ) ; \n / / Doc gia tri cho bien2 co kieu thưc \n scanf ( “ % f ” , & bien2 ) ; \n / / Doc gia tri cho Dai và Rong co thuc \n scanf ( “ % f % f ” , & Dai , & Rong ) ; \n / / bien3 nhận giá trị là 1 ký tự \n scanf ( “ % c ” , & bien3 ) ; \n Lưu ý : \n o Chuỗi định dạng phải đặt trong cặp dấu nháy kép ( “ ” ) . \n o Các địa chỉ biến phải cách nhau bởi dấu phẩy ( , ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 44}}
{"text": "ự \n scanf ( “ % c ” , & bien3 ) ; \n Lưu ý : \n o Chuỗi định dạng phải đặt trong cặp dấu nháy kép ( “ ” ) . \n o Các địa chỉ biến phải cách nhau bởi dấu phẩy ( , ) . \n o Có bao nhiêu biến thì phải có bấy nhiêu định dạng . \n o Thứ tự của các định dạng phải phù hợp với thứ tự của các \n biến . \n o Để nhập giá trị ký tự ( hoặc chuỗi ký tự ) được chính xác , \n hàm fflush ( stdin ) nên được sử dụng để loại bỏ các ký tự \n còn nằm trong vùng đệm bàn phím trước khi sử dụng hàm \n scanf ( ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 44}}
{"text": "Lập trình căn bản \n o Để nhập vào một chuỗi ký tự ( không chứa khoảng trắng \n hay kết thúc bằng khoảng trắng ) , chúng ta có thể khai báo \n kiểu mảng ký tự , sử dụng định dạng % s và tên biến thay \n cho địa chỉ biến . \n o Để đọc vào một chuỗi ký tự có chứa khoảng trắng ( kết \n thúc bằng phím Enter ) thì phải dùng hàm gets ( ) . \n Ví dụ : \n int biennguyen ; \n float bienthuc ; \n char bienchar ; \n char chuoi1 [ 20 ] , chuoi2 [ 20 ] ; \n Nhập giá trị cho các biến : \n scanf ( “ % 3d ” , & biennguyen ) ; \n Nếu ta nhập 1234455 thì giá trị của biennguyen là 3 ký số \n đầu tiên ( 123 ) . Các ký số còn lại sẽ còn nằm lại trong vùng đệm . \n scanf ( “ % 5f ” , & bienthuc ) ; \n Nếu ta nhập 123.446 thì giá trị của bienthuc là 123.4 , các \n ký số còn lại sẽ còn nằm trong vùng đệm . \n scanf ( “ % 2d % 5f ” , & biennguyen , & bienthuc ) ; \n Nếu ta nhập liên tiếp 2 số cách nhau bởi khoảng trắng như \n sau : 1223 3.142325 \n - 2 ký số đầu tiên ( 12 ) sẽ được đọc vào cho biennguyen . \n - 2 ký số tiếp theo trước khoảng trắng ( 23 ) sẽ được đọc \n vào cho bienthuc .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 45}}
{"text": "ớc khoảng trắng ( 23 ) sẽ được đọc \n vào cho bienthuc . \n scanf ( “ % 2d % 5f % c ” , & biennguyen , & bienthuc , \n & bienchar ) ; \n Nếu ta nhập liên tiếp 2 số cách nhau bởi khoảng trắng như \n sau : 12345 3.142325 : \n - 2 ký số đầu tiên ( 12 ) sẽ được đọc vào cho biennguyen . \n - 3 ký số tiếp theo trước khoảng trắng ( 345 ) sẽ được đọc \n vào cho bienthuc . \n - Khoảng trắng sẽ được đọc cho bienchar .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 45}}
{"text": "Lập trình căn bản \n Nếu ta chỉ nhập 1 số gồm nhiều ký số như sau : \n 123456789 : \n - 2 ký số đầu tiên ( 12 ) sẽ được đọc vào cho biennguyen . \n - 5 ký số tiếp theo ( 34567 ) sẽ được đọc vào cho bienthuc . \n - bienchar sẽ có giá trị là ký số tiếp theo ‘ 8 ’ . \n scanf ( “ % s ” , chuoi1 ) ; \n hoặc scanf ( “ % s ” , chuoi2 ) ; \n Nếu ta nhập chuỗi như sau : Nguyen Van Linh  thì giá trị \n của biến chuoi1 hay chuoi2 chỉ là Nguyen . \n scanf ( “ % s % s ” , chuoi1 , chuoi2 ) ; \n Nếu ta nhập chuỗi như sau : Duong Van Hieu  thì giá trị \n của biến chuoi1 là Duong và giá trị của biến chuoi2 là Van . \n Vì sao như vậy ? C sẽ đọc từ đầu đến khi gặp khoảng trắng \n và gán giá trị cho biến đầu tiên , phần còn lại sau khoảng trắng là \n giá trị của các biến tiếp theo . \n gets ( chuoi1 ) ; \n Nếu nhập chuỗi : Nguyen Van Linh  thì giá trị của biến \n chuoi1 là Nguyen Van Linh \n II. 3 . Hiển thị giá trị của biểu thức lên màn hình ( hàm printf ) \n Hàm printf ( ) ( nằm trong thư viện stdio . h ) dùng để hiển thị \n ( in ) giá trị của các biểu thức lên màn hình . \n Cú pháp : \n printf ( “ Chuỗi định dạng ” , Các biểu thức ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 46}}
{"text": "thị \n ( in ) giá trị của các biểu thức lên màn hình . \n Cú pháp : \n printf ( “ Chuỗi định dạng ” , Các biểu thức ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 46}}
{"text": "Lập trình căn bản \n Giải thích : \n - Chuỗi định dạng : dùng để quy định kiểu dữ liệu , cách \n biểu diễn , độ rộng , số chữ số thập phân ... Bảng dưới đây là một \n số định dạng khi hiển thị các biểu thức số nguyên , số thực , ký \n tự , ... :\n\n| Định dạng |  | Ý nghĩa |\n| --- | --- | --- |\n| %d |  | In số nguyên |\n| %[.số chữ số thập phân] f |  | In số thực có <số chữ số thập phân> theo quy tắc làm tròn số. |\n| %o |  | In số nguyên hệ bát phân |\n| %x |  | In số nguyên hệ thập lục phân |\n| %c |  | In một ký tự |\n| %s |  | In chuỗi ký tự |\n| %e hoặc %E hoặc %g hoặc %G |  | In số nguyên dạng khoa học (nhân 10 mũ x) |\n| Thí dụ |  |  |\n| %d | In ra số nguyên |  |\n| %4d | In số nguyên tối đa 4 ký số, nếu số cần in nhiều hơn 4 ký số thì in hết |  |\n| %f | In số thực |  |\n| %6f | In số thực tối đa 6 ký số (tính luôn dấu chấm), nếu số cần in nhiều hơn 6 ký số thì in hết |  |\n| %.3f | In số thực có 3 số lẻ, nếu số cần in có nhiều hơn 3 số lẻ thì làm tròn. |  |\n\n\n- Các biểu thức : là các biểu thức mà chúng ta cần hiển thị \n giá trị của nó lên màn hình , mỗi biểu thức phân cách nhau bởi \n dấu phẩy ( , ) . \n Thí dụ : \n include < stdio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 47}}
{"text": "mà chúng ta cần hiển thị \n giá trị của nó lên màn hình , mỗi biểu thức phân cách nhau bởi \n dấu phẩy ( , ) . \n Thí dụ : \n include < stdio . h > \n main ( ) { \n int bien nguyen = 1234 , i = 65 ; \n float bien thuc = 123.456703 ; \n printf ( “ Gia tri nguyen cua bien nguyen \n = % d \\ n ” , bien nguyen ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 47}}
{"text": "Lập trình căn bản \n printf ( “ Gia tri thuc cua bien thuc \n = % f \\ n ” , bien thuc ) ; \n printf ( “ Truoc khi lam tron = % f \\ n \n Sau khi lam tron = % . 2f ” , \n bien thuc , bien thuc ) ; \n } \n Kết quả in ra màn hình như sau : \n Nếu ta thêm vào dòng sau trong chương trình : \n printf ( “ \\ n Ky tu co ma ASCII % d la % c ” , i , i ) ; \n Kết quả ta nhận được thêm : \n printf ( “ So nguyen la % d \\ n \n So thuc la % f ” , i , ( float ) i ) ; \n printf ( “ \\ n So thuc la % f \\ n \n So nguyen la % d ” , bien thuc , ( int ) bien thuc ) ; \n printf ( “ \\ n Viet binh thuong = % f \\ n \n Viet kieu khoa hoc = % e ” , bien thuc , bien thuc ) ; \n Kết quả in ra màn hình : \n Lưu ý : Đối với các ký tự điều khiển , ta không thể sử dụng cách \n viết thông thường để hiển thị chúng . \n Ký tự điều khiển là các ký tự dùng để điều khiển các thao \n tác xuất , nhập dữ liệu .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 48}}
{"text": "Lập trình căn bản \n Một số ký tự điều khiển :\n\n| Ký tự điều khiển | Giá trị thập lục phân | Ký tự được hiển thị | Ý nghĩa |\n| --- | --- | --- | --- |\n| \\a | 0x07 | BEL | Phát ra tiếng chuông |\n| \\b | 0x08 | BS | Di chuyển con trỏ sang trái 1 ký tự và xóa ký tự bên trái (backspace) |\n| \\f | 0x0C | FF | Sang trang |\n| \\n | 0x0A | LF | Xuống dòng |\n| \\r | 0x0D | CR | Trở về đầu dòng |\n| \\t | 0x09 | HT | Tab theo cột (giống gõ phím Tab) |\n| \\\\ | 0x5C | \\ | Dấu \\ |\n| \\’ | 0x2C | ‘ | Dấu nháy đơn (‘) |\n| \\” | 0x22 | “ | Dấu nháy kép (“) |\n| \\? | 0x3F | ? | Đấu chấm hỏi (?) |\n| \\ddd | ddd | Ký tự có mã ACSII trong hệ bát phân là số ddd |  |\n| \\xHHH | 0xHHH | Ký tự có mã ACSII trong hệ thập lục phân là HHH |  |\n\n\nThí dụ : \n # include < stdio . h > \n # include < conio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 49}}
{"text": "printf ( \" \\ n Dau cham hoi \\ ? \" ) ; \n printf ( \" \\ n Ky tu co ma bat phan 101 \n la \\ 101 \" ) ; \n printf ( \" \\ n Ky tu co ma thap luc phan 41 \n la \\ x041 \" ) ; \n printf ( \" \\ n Dong hien tai , xin go enter \" ) ; \n getch ( ) ; \n printf ( \" \\ rVe dau dong \" ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 49}}
{"text": "Lập trình căn bản \n Kết quả trước khi gõ phím Enter : \n Kết quả sau khi gõ phím Enter : \n III. MỘT THÍ DỤ \n Viết chương trình cho phép nhận từ bàn phím 2 số thực biểu diễn \n cho chiều dài và chiều rộng của 1 hình chữ nhật . Tính chu vi và \n diện tích của hình chữ nhật đó và hiển thị kết quả lên màn hình . \n Với yêu cầu của chương trình này thì đầu vào và đầu ra của \n chương trình là : \n Đầu vào : 2 số thực chiều dài và chiều rộng . \n Đầu ra : chu vi và diện tích của hình chữ nhật . \n Chương trình sau giải quyết được vấn đề trên : \n # include < stdio . h > \n # include < conio . h > \n main ( ) \n { \n float Dai , Rong , Chu Vi , Dien Tich ; \n / / 1 . Nhập chiều dài và chiều rộng \n printf ( \" Chieu dai : \" ) ; scanf ( \" % f \" , & Dai ) ; \n printf ( \" Chieu rong : \" ) ; scanf ( \" % f \" , & Rong ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 50}}
{"text": "Lập trình căn bản \n / / 2 . Tính chu vi và diện tích hình chữ nhật \n Chu Vi = 2 * ( Dai + Rong ) ; \n Dien Tich = Dai * Rong ; \n / / 3 . Hiển thị kết quả \n printf ( \" Chu vi la % . 3f \\ n \n Dien tich la % . 3f \" , Chu Vi , Dien Tich ) ; \n getch ( ) ; \n } \n IV. BÀI TẬP \n 1 . Viết chương trình in lên màn hình một thiệp mời dự sinh nhật \n có dạng : \n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n THIEP MOI \n Thân mời bạn : Nguyễn Mạnh Hùng \n Tới dự lễ sinh nhật của mình \n Vào lúc 19h ngày 12 / 10 / 2009 \n Tại 05 / 42 Trần Phú - Cần Thơ \n Rất mong được đón tiếp ! \n Hồ Thu Hương \n * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * \n 2 . Viết chương trình nhập vào bán kính r của một hình tròn . Tính \n chu vi và diện tích của hình tròn theo công thức : \n Chu vi CV = 2 * Pi * r \n Diện tích S = Pi * r * r \n In các kết quả lên màn hình", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 51}}
{"text": "Lập trình căn bản \n 3 . Viết chương trình nhập vào độ dài 3 cạnh a , b , c của một tam \n giác . Tính chu vi và diện tích của tam giác theo công thức : \n Chu vi CV = a + b + c \n Diện tích S = sqrt ( p * ( p - a ) * ( p - b ) * ( p - c ) ) \n Trong đó : p = CV / 2 \n In các kết quả lên màn hình \n 4 . Viết chương trình tính log x với a , x là các số thực nhập vào từ \n a \n bàn phím với giả thiết x > 0 , a > 0 , a ! = 1 . ( dùng log x = lnx / lna ) \n a \n 5 . Viết chương trình nhập vào tọa độ của hai điểm ( x1 , y1 ) và \n ( x2 , y2 ) \n a ) Tính hệ số góc của đường thẳng đi qua hai điểm đó theo \n công thức : \n Hệ số góc = ( y2 - y1 ) / ( x2 - x1 ) \n b ) Tính khoảng cách giữa hai điểm theo công thức : \n Khoảng cách =  y  y  2   x  x  2 \n 2 1 2 1 \n 6 . Viết chương trình nhập vào một ký tự : \n a ) In ra mã Ascii của ký tự đó . \n b ) In ra ký tự kế tiếp của nó . \n 7 . Viết chương trình nhập vào các giá trị điện trở R1 , R2 , R3 của \n một mạch điện : \n 1 1 1 1 \n Tính tổng trở theo công thức :    \n R R R R \n 1 2 3 \n 8 . Viết chương trình nhập vào điểm ba môn Toán , Lý , Hóa của \n một học sinh . In ra điểm trung bình của học sinh đó với hai số lẻ \n thập phân . \n 9 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 52}}
{"text": "   \n R R R R \n 1 2 3 \n 8 . Viết chương trình nhập vào điểm ba môn Toán , Lý , Hóa của \n một học sinh . In ra điểm trung bình của học sinh đó với hai số lẻ \n thập phân . \n 9 . Viết chương trình nhập vào ngày , tháng , năm . In ra ngày tháng \n năm theo dạng dd / mm / yy . ( dd : ngày , mm : tháng , yy : năm . Thí \n dụ : 20 / 11 / 99 ) \n 10 . Viết chương trình đảo ngược một số nguyên dương có đúng 3 \n chữ số .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 52}}
{"text": "Lập trình căn bản \n Chương 4 \n CÁC LỆNH CÓ CẤU TRÚC \n Chương này trình bày về các câu lệnh có cấu trúc trong C. \n Nội dung chính của chương này gồm : \n  Khối lệnh trong C. \n  Cấu trúc rẽ nhánh . \n  Cấu trúc lựa chọn . \n  Cấu trúc vòng lặp \n  . Các câu lệnh “ đặc biệt ” . \n I. KHỐI LỆNH \n Một dãy các khai báo cùng với các câu lệnh nằm trong cặp \n dấu ngoặc móc { và } được gọi là một khối lệnh . \n Thí dụ 1 : \n { \n char ten [ 30 ] ; \n printf ( “ \\ n Nhap vao ten cua ban : ” ) ; \n scanf ( “ % s ” , ten ) ; \n printf ( “ \\ n Chao Ban % s ” , ten ) ; \n } \n Thí dụ 2 : \n # include < stdio . h > \n # include < conio . h > \n main ( ) \n { / * đây là đầu khối * / \n char ten [ 50 ] ; \n printf ( \" Xin cho biet ten cua ban ! \" ) ; \n scanf ( \" % s \" , ten ) ; \n getch ( ) ; \n } / * đây là cuối khối * /", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 53}}
{"text": "Lập trình căn bản \n Một khối lệnh có thể chứa bên trong nó nhiều khối lệnh \n khác gọi là khối lệnh lồng nhau . Sự lồng nhau của các khối lệnh \n là không hạn chế . \n Minh họa : \n { \n … lệnh ; \n { \n … lệnh ; \n { \n … lệnh ; \n } \n … lệnh ; \n } \n … lệnh ; \n } \n Lưu ý về phạm vi tác động của biến trong khối lệnh \n lồng nhau : \n - Trong các khối lệnh khác nhau hay các khối lệnh lồng \n nhau có thể khai báo các biến cùng tên . \n Thí dụ 1 : \n { \n … lệnh ; \n { \n int a , b ; / * biến a , b trong khối lệnh thứ nhất * / \n … lệnh ; \n } \n … lệnh ; \n { \n int a , b ; / * biến a , b trong khối lệnh thứ hai * / \n … lệnh ; \n } \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 54}}
{"text": "Lập trình căn bản \n Thí dụ 2 : \n { \n int a , b ; / * biến a , b trong khối lệnh “ bên ngoài ” * / \n … lệnh ; \n { \n int a , b ; / * biến a , b bên trong khối lệnh con * / \n } \n } \n - Nếu một biến được khai báo bên ngoài khối lệnh và \n không trùng tên với biến bên trong khối lệnh thì nó cũng được sử \n dụng bên trong khối lệnh . \n - Một khối lệnh con có thể sử dụng các biến bên ngoài , các \n lệnh bên ngoài không thể sử dụng các biến bên trong khối lệnh \n con . \n Thí dụ : \n { \n int a , b , c ; \n … lệnh ; \n { \n int c , d ; \n … lệnh ; \n } \n } \n II. CẤU TRÚC RẼ NHÁNH \n Cấu trúc rẽ nhánh là một cấu trúc được dùng rất phổ biến \n trong các ngôn ngữ lập trình nói chung . Cấu trúc này thể hiện \n suy nghĩ dạng nếu … thì của con người . Cấu trúc rẽ nhánh có \n hai dạng : dạng không đầy đủ và dạng đầy đủ .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 55}}
{"text": "Lập trình căn bản \n II. 1 . Dạng không đầy đủ \n Cú pháp : \n if ( < Biểu thức điều kiện > ) \n < Công việc > \n Lưu đồ cú pháp : \n Giải thích : \n < Công việc > được thể hiện bằng 1 câu lệnh \n hay 1 khối lệnh . \n Đầu tiên Điều kiện được kiểm tra . \n Nếu điều kiện đúng ( ! = 0 ) thì thực hiện câu \n lệnh hoặc khối lệnh ( Công việc ) liền sau \n điều kiện . \n Nếu điều kiện sai thì bỏ qua lệnh hoặc khối \n lệnh liền sau điều kiện ( những lệnh và khối \n lệnh sau đó vẫn được thực hiện bình thường \n vì nó không phụ thuộc vào điều kiện sau if ) . \n Thí dụ 1 : Nhập vào một số thực a từ bàn phím . In ra màn \n hình kết quả nghịch đảo của a khi a  0 . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n float a ; \n printf ( \" Nhap a = \" ) ; scanf ( \" % f \" , & a ) ; \n if ( a ! = 0 ) \n printf ( \" Nghich dao cua % f la % f \" , a , 1 / a ) ; \n getch ( ) ; \n } \n Giải thích : \n - Nếu giá trị nhập vào a  0 thì câu lệnh printf ( \" Nghich \n dao cua % f la % f \" , a , 1 / a ) được thực hiện , ngược lại câu lệnh \n này không được thực hiện . \n - Lệnh getch ( ) luôn luôn được thực hiện vì nó không phải \n là “ lệnh liền sau ” điều kiện if .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 56}}
{"text": "ợc lại câu lệnh \n này không được thực hiện . \n - Lệnh getch ( ) luôn luôn được thực hiện vì nó không phải \n là “ lệnh liền sau ” điều kiện if .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 56}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Nhập vào giá trị của 2 số a và b từ bàn phím , nếu \n a lớn hơn b thì in ra thông báo “ Gia trị của a lớn hơn giá trị của \n b ” , sau đó hiển thị giá trị cụ thể của 2 số lên màn hình . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int a , b ; \n printf ( \" Nhap vao gia tri cua 2 so a , b ! \" ) ; \n scanf ( \" % d % d \" , & a , & b ) ; \n if ( a > b ) { \n printf ( \" \\ n Gia tri cua a lon hon \n gia tri cua b \" ) ; \n printf ( \" \\ n a = % d , b = % d \" , a , b ) ; \n } \n getch ( ) ; \n } \n Giải thích : \n Nếu ta nhập vào giá trị của a lớn hơn giá trị của b thì khối \n lệnh : \n { \n printf ( \" \\ n Gia tri cua a lon hon \n gia tri cua b \" ) ; \n printf ( \" \\ n a = % d , b = % d \" , a , b ) ; \n } \n sẽ được thực hiện , ngược lại khối lệnh này không được \n thực hiện . \n II. 2 . Dạng đầy đủ \n Cú pháp : \n if ( < Biểu thức điều kiện > ) \n < Công việc 1 > \n else \n < Công việc 2 >", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 57}}
{"text": "Lập trình căn bản \n Lưu đồ cú pháp : \n Giải thích : \n Công việc 1 , công việc 2 được thể \n hiện là 1 câu lệnh hay 1 khối lệnh . \n Đầu tiên Biểu thức điều kiện được \n kiểm tra trước . \n Nếu điều kiện đúng thì thực hiện \n công việc 1 . \n Nếu điều kiện sai thì thực hiện công \n việc 2 . \n Các lệnh phía sau công việc 2 không \n phụ thuộc vào điều kiện . \n Thí dụ 1 : Viết chương trình nhập vào một số thực a từ bàn \n phím . In ra màn hình kết quả nghịch đảo của a khi a  0 , khi a = 0 \n in ra thông báo “ Khong the tim duoc nghich dao cua a ” \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n float a ; \n printf ( \" Nhap a = \" ) ; scanf ( \" % f \" , & a ) ; \n if ( a ! = 0 ) \n printf ( \" Nghich dao cua % f la % f \" , a , 1 / a ) ; \n else \n printf ( “ Khong the tim duoc nghich dao \n cua a ” ) ; \n getch ( ) ; \n } \n Giải thích : \n - Nếu ta nhập vào giá trị a  0 thì câu lệnh \n printf ( \" Nghich dao cua % f la % f \" , a , 1 / a ) được thực hiện , \n ngược lại câu lệnh printf ( “ Khong the tim duoc nghich \n dao cua a ” ) được thực hiện . \n - Lệnh getch ( ) luôn luôn được thực hiện .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 58}}
{"text": "he tim duoc nghich \n dao cua a ” ) được thực hiện . \n - Lệnh getch ( ) luôn luôn được thực hiện .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 58}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Viết chương trình cho phép nhập vào giá trị của \n 2 số a và b từ bàn phím . nếu a lớn hơn b thì in ra thông báo “ a lon \n hon b ” và hiển thị giá trị của 2 số lên màn hình , ngược lại thì in \n ra màn hình câu thông báo “ a nho hon hoặc bang b ” và hiển thị \n giá trị của 2 số lên màn hình . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int a , b ; \n printf ( \" Nhap vao gia tri cua 2 so a va b ! \" ) ; \n scanf ( \" % d % d \" , & a , & b ) ; \n if ( a > b ) { \n printf ( \" \\ n a lon hon b ” ) ; \n printf ( \" \\ n a = % d b = % d \" , a , b ) ; \n } \n else { \n printf ( \" \\ n a nho hon hoac bang b \" ) ; \n printf ( \" \\ n a = % d b = % d \" , a , b ) ; \n } \n printf ( \" \\ n Thuc hien xong lenh if \" ) ; \n getch ( ) ; \n } \n Giải thích : \n - Nếu ta nhập vào 40 30  thì kết quả hiển thị trên màn \n hình là \n a lon hon b \n a = 40 b = 30 \n Thuc hien xong lenh if \n - Còn nếu ta nhập 40 50  thì kết quả hiển thị trên màn \n hình là \n a nho hon hoac bang b \n a = 40 b = 50 \n Thuc hien xong lenh if", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 59}}
{"text": "40 b = 50 \n Thuc hien xong lenh if", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 59}}
{"text": "Lập trình căn bản \n Thí dụ 3 : Viết chương trình nhập vào một số nguyên \n dương là tháng trong năm . Hiển thị và số ngày của tháng đó lên \n màn hình . \n Gợi ý : - Tháng có 31 ngày : 1 , 3 , 5 , 7 , 8 , 10 , 12 \n - Tháng có 30 ngày : 4 , 6 , 9 , 10 \n - Tháng có 28 hoặc 29 ngày : 2 \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int thg ; \n printf ( \" Nhap vao thang trong nam ! \" ) ; \n scanf ( \" % d \" , & thg ) ; \n if ( thg = = 1 | | thg = = 3 | | thg = = 5 | | thg = = 7 | | thg = = 8 \n | | thg = = 10 | | thg = = 12 ) \n printf ( \" \\ n Thang % d co 31 ngay \" , thg ) ; \n else if ( thg = = 4 | | thg = = 6 | | thg = = 9 | | thg = = 11 ) \n printf ( \" \\ n Thang % d co 30 ngay \" , thg ) ; \n else if ( thg = = 2 ) \n printf ( \" \\ n Thang % d co 28 hoac \n 29 ngay \" , thg ) ; \n else printf ( \" Khong co thang % d \" , thg ) ; \n printf ( \" \\ n Thuc hien xong lenh if \" ) ; \n getch ( ) ; \n } \n Giải thích : \n - Nếu ta nhập vào một trong các số 1 , 3 , 5 , 7 , 8 , 10 , 12 thì \n kết quả xuất hiện trên màn hình sẽ là : \n Thang < số > co 31 ngay \n Thuc hien xong lenh if \n - Nếu chúng ta nhập vào một trong các số 4 , 6 , 9 , 11 thì \n kết quả xuất hiện trên màn hình sẽ là \n Thang < số > c", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 60}}
{"text": "uất hiện trên màn hình sẽ là : \n Thang < số > co 31 ngay \n Thuc hien xong lenh if \n - Nếu chúng ta nhập vào một trong các số 4 , 6 , 9 , 11 thì \n kết quả xuất hiện trên màn hình sẽ là \n Thang < số > co 30 ngay \n Thuc hien xong lenh if", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 60}}
{"text": "Lập trình căn bản \n - Nếu ta nhập vào số 2 thì kết quả xuất hiện trên màn hình \n sẽ là \n Thang 2 co 28 hoac 29 ngay \n Thuc hien xong lenh if \n - Nếu ta nhập vào số nhỏ hơn 0 hoặc lớn hơn 12 thì kết \n quả xuất hiện trên màn hình sẽ là \n Khong co thang < số > \n Thuc hien xong lenh if \n Trong đó < số > là con số mà chúng ta đã nhập vào . \n Lưu ý : \n - Ta có thể sử dụng các câu lệnh if … else lồng nhau . Trong \n trường hợp if … else lồng nhau thì else sẽ kết hợp với if gần nhất \n chưa có else . \n - Trong trường hợp câu lệnh if “ bên trong ” không có else \n thì phải viết nó trong cặp dấu { } ( coi như là khối lệnh ) để tránh \n sự kết hợp else if sai . \n Thí dụ 1 : \n if ( so1 > 0 ) \n if ( so2 > so3 ) \n a = so2 ; \n else / * else của if ( so2 > so3 ) * / \n a = so3 ; \n Thí dụ 2 : \n if ( so1 > 0 ) \n { \n if ( so2 > so3 ) / * lệnh if này không \n có else * / \n a = so2 ; \n } \n else / * else của if ( so1 > 0 ) * / \n a = so3 ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 61}}
{"text": "Lập trình căn bản \n III. CẤU TRÚC LỰA CHỌN \n Cấu trúc lựa chọn cho phép lựa chọn một trong nhiều trường \n hợp . Trong C , đó là câu lệnh switch . \n Cú pháp : \n switch ( < Biến > ) \n { \n case giá trị 1 : \n Khối lệnh thực hiện công việc 1 ; \n break ; \n … \n case giá trị n : \n Khối lệnh thực hiện công việc n ; \n break ; \n [ default : \n Khối lệnh thực hiện công việc mặc định ; \n } \n Giải thích : \n - Trước tiên Biến được ước lượng giá trị . \n - Nếu giá trị của biểu thức bằng giá trị 1 thì thực hiện \n công việc 1 rồi thoát . \n - Nếu giá trị của biểu thức khác giá trị 1 thì so sánh với \n giá trị 2 , nếu bằng giá trị 2 thì thực hiện công việc 2 rồi thoát . \n - Cứ như thế , so sánh tới giá trị n . \n - Nếu tất cả các phép so sánh trên đều sai thì thực hiện \n công việc mặc định của trường hợp default . \n Lưu ý : \n - Biểu thức trong switch ( ) phải có kết quả là giá trị kiểu số \n nguyên ( int , char , long , … ) . \n - Các giá trị sau case cũng phải là kiểu số nguyên . \n - Không bắt buộc phải có default .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 62}}
{"text": "Lập trình căn bản \n Thí dụ 1 : Nhập vào một số nguyên , chia số nguyên này \n cho 2 lấy phần dư . Kiểm tra nếu phần dư bằng 0 thì in ra thông \n báo “ số chẵn ” , nếu số dư bằng 1 thì in thông báo “ số lẻ ” . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int songuyen , phandu ; \n printf ( \" \\ n Nhap vao so nguyen \" ) ; \n scanf ( \" % d \" , & songuyen ) ; \n phandu = ( songuyen % 2 ) ; \n switch ( phandu ) { \n case 0 : \n printf ( \" % d la so chan \" , songuyen ) ; \n break ; \n case 1 : \n printf ( \" % d la so le \" , songuyen ) ; \n break ; \n } \n getch ( ) ; \n } \n Thí dụ 2 : Nhập vào 2 số thực và 1 phép toán . \n - Nếu phép toán là ‘ + ’ , ‘ - ‘ , ‘ * ’ thì in ra kết qua là tổng , \n hiệu , tích của 2 số . \n - Nếu phép toán là ‘ / ’ thì kiểm tra xem số thứ 2 có khác \n không hay không ? Nếu khác không thì in ra thương của chúng , \n ngược lại thì in ra thông báo “ khong chia cho 0 ” . \n # include < stdio . h > \n # include < conio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 63}}
{"text": "rintf ( \" Nhap a = \" ) ; scanf ( \" % f \" , & a ) ; \n printf ( \" Nhap b = \" ) ; scanf ( \" % f \" , & b ) ; \n fflush ( stdin ) ; \n printf ( \" Phep toan = \" ) ; scanf ( \" % c \" , & pt ) ; \n switch ( pt ) {", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 63}}
{"text": "Lập trình căn bản \n case ' + ' : \n printf ( \" % f + % f = % f \" , a , b , a + b ) ; \n break ; \n case ' - ' : \n printf ( \" % f - % f = % f \" , a , b , a - b ) ; \n break ; \n case ' * ' : \n printf ( \" % f * % f = % f \" , a , b , a * b ) ; \n break ; \n case ' / ' : \n if ( b = = 0 ) printf ( \" Khong chia dc \" ) ; \n else printf ( \" % f / % f = % f \" , \n a , b , a / b ) ; \n break ; \n default : \n printf ( \" Khong co phep toan % c \" , pt ) ; \n } \n getch ( ) ; \n } \n Trong cấu trúc lựa chọn switch … case , từ khóa break là \n không bắt buộc . Tuy nhiên , nếu không có từ khóa break ở cuối \n mỗi case ; khi biến trong phần switch bằng với 1 giá trị nào đó , \n phần công việc sau case tương ứng được thực hiện , sau đó các \n phần công việc sau case kế tiếp cũng được thực hiện . \n Thí dụ 3 : Yêu cầu người thực hiện chương trình nhập vào \n một số nguyên dương là tháng trong năm và in ra số ngày của \n tháng đó . \n - Tháng có 31 ngày : 1 , 3 , 5 , 7 , 8 , 10 , 12 \n - Tháng có 30 ngày : 4 , 6 , 9 , 10 \n - Tháng có 28 hoặc 29 ngày : 2 \n - Nếu nhập vào số < 1 hoặc > 12 thì in ra câu thông báo \n “ không có tháng này “ .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 64}}
{"text": "ng có 28 hoặc 29 ngày : 2 \n - Nếu nhập vào số < 1 hoặc > 12 thì in ra câu thông báo \n “ không có tháng này “ .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 64}}
{"text": "Lập trình căn bản \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int thang ; \n printf ( \" \\ n Nhap vao thang trong nam \" ) ; \n scanf ( \" % d \" , & thang ) ; \n switch ( thang ) { \n case 1 : \n case 3 : \n case 5 : \n case 7 : \n case 8 : \n case 10 : \n case 12 : \n printf ( \" \\ n Thang % d co 31 ngay \" , thang ) ; \n break ; \n case 4 : \n case 6 : \n case 9 : \n case 11 : \n printf ( \" \\ n Thang % d co 30 ngay \" , thang ) ; \n break ; \n case 2 : \n printf ( \" \\ Thang 2 co 28 hoac 29 ngay \" ) ; \n break ; \n default : \n printf ( \" \\ n Khong co thang % d \" , thang ) ; \n break ; \n } \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 65}}
{"text": "Lập trình căn bản \n IV. VÒNG LẶP \n Cấu trúc vòng lặp cho phép lặp lại nhiều lần 1 công việc \n ( được thể hiện bằng 1 câu lệnh hay 1 khối lệnh ) nào đó cho đến \n khi thỏa mãn 1 điều kiện cụ thể . \n IV. 1 . Vòng lặp for \n Vòng lặp này cho phép lặp lại công việc trong khi điều \n kiện còn đúng . \n Cú pháp : \n for ( Biểu thức 1 ; biểu thức 2 ; biểu thức 3 ) \n < Công việc > \n Lưu đồ : \n Giải thích : \n < Công việc > : được thể hiện là 1 câu lệnh hay 1 khối lệnh . \n Thứ tự thực hiện của câu lệnh for như sau : \n Bước 1 : Tính giá trị của biểu thức 1 . \n Bước 2 : Tính giá trị của biểu thức 2 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 66}}
{"text": "Lập trình căn bản \n - Nếu giá trị của biểu thức 2 là sai ( = 0 ) : thoát khỏi \n câu lệnh for . \n - Nếu giá trị của biểu thức 2 là đúng ( ! = 0 ) : < Công \n việc > được thực hiện . \n Bước 3 : Tính giá trị của biểu thức 3 và quay lại bước 2 . \n Một số lưu ý khi sử dụng câu lệnh for : \n - Khi biểu thức 2 vắng mặt thì nó được coi là luôn luôn \n đúng \n - Biểu thức 1 : thông thường là một phép gán để khởi tạo \n giá trị ban đầu cho biến điều kiện . \n - Biểu thức 2 : là một biểu thức kiểm tra điều kiện đúng sai \n để tiếp tục hay dừng vòng lặp . \n - Biểu thức 3 : thông thường là một phép gán để thay đổi \n giá trị của biến điều kiện . \n - Trong mỗi biểu thức có thể có nhiều biểu thức con . Các \n biểu thức con được phân biệt bởi dấu phẩy . \n Thí dụ 1 : Viết chương trình in dãy số nguyên từ 1 đến 10 . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int i ; \n printf ( \" \\ n Day so tu 1 den 10 : \" ) ; \n for ( i = 1 ; i < = 10 ; i + + ) \n printf ( \" % d \" , i ) ; \n getch ( ) ; \n } \n Kết quả chương trình như sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 67}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Viết chương trình nhập vào một số nguyên n . \n Tính tổng của các số nguyên từ 1 đến n . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int n , i , tong ; \n printf ( \" Nhap vao so nguyen duong n : \" ) ; \n scanf ( \" % u \" , & n ) ; \n tong = 0 ; \n for ( i = 1 ; i < = n ; i + + ) \n tong + = i ; \n printf ( \" \\ n Tong tu 1 den % u = % u \" , n , tong ) ; \n getch ( ) ; \n } \n Nếu chúng ta nhập vào số 9 thì kết quả như sau : \n Thí dụ 3 : Viết chương trình in ra trên màn hình một ma \n trận có n dòng m cột như sau : \n 1 2 3 4 5 6 7 \n 2 3 4 5 6 7 8 \n 3 4 5 6 7 8 9 \n … \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int dong , cot , n , m ; \n printf ( \" \\ n Nhap vao so dong va so cot : \" ) ; \n scanf ( \" % u % u \" , & n , & m ) ; \n for ( dong = 0 ; dong < n ; dong + + ) { \n printf ( \" \\ n \" ) ; \n for ( cot = 1 ; cot < = m ; cot + + ) \n printf ( \" % u \\ t \" , dong + cot ) ; \n } \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 68}}
{"text": "Lập trình căn bản \n Kết quả khi nhập 3 dòng 6 cột như sau \n III. 2 . Vòng lặp while \n Vòng lặp while giống như vòng lặp for , dùng để lặp lại \n một công việc nào đó trong khi điều kiện còn đúng . \n Cú pháp : \n while ( Biểu thức điều kiện ) \n < Công việc > \n Lưu đồ : \n Giải thích : \n - Công việc : được thể hiện bằng 1 \n câu lệnh hay 1 khối lệnh . \n - Trước tiên điều kiện được kiểm \n tra . \n - Nếu điều kiện sai ( = 0 ) thì thoát \n khỏi lệnh while . \n - Nếu điều kiện đúng ( ! = 0 ) thì \n thực hiện công việc rồi quay lại \n kiểm tra điều kiện tiếp . \n Lưu ý : \n - Lệnh while gồm có biểu thức điều kiện và thân vòng lặp \n ( khối lệnh thực hiện công việc ) \n - Vòng lặp dừng lại khi điều kiện sai . \n - Khối lệnh thực hiện công việc có thể rỗng , có thể làm \n thay đổi điều kiện .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 69}}
{"text": "Lập trình căn bản \n Thí dụ 1 : Viết chương trình in dãy số nguyên từ 1 đến 10 . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int i ; \n printf ( \" \\ n Day so tu 1 den 10 : \" ) ; \n i = 1 ; \n while ( i < = 10 ) { \n printf ( \" % d \" , i ) ; \n i + + ; \n } \n getch ( ) ; \n } \n Kết quả chương trình như sau : \n Thí dụ 2 : Viết chương trình nhập vào một số nguyên n . \n Tính tổng của các số nguyên từ 1 đến n . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int n , i , tong ; \n printf ( \" \\ n Nhap vao so nguyen duong n : \" ) ; \n scanf ( \" % u \" , & n ) ; \n tong = 0 ; \n i = 1 ; \n while ( i < = n ) { \n tong + = i ; \n i + + ; \n } \n printf ( \" \\ n Tong tu 1 den % u = % u \" , n , tong ) ; \n getch ( ) ; \n } \n Nếu chúng ta nhập vào số 9 thì kết quả như sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 70}}
{"text": "Lập trình căn bản \n Thí dụ 3 : Viết chương trình in ra trên màn hình một ma \n trận có n dòng m cột như sau : \n 1 2 3 4 5 6 7 \n 2 3 4 5 6 7 8 \n 3 4 5 6 7 8 9 \n … \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int dong , cot , n , m ; \n printf ( \" \\ n Nhap vao so dong va so cot : \" ) ; \n scanf ( \" % u % u \" , & n , & m ) ; \n dong = 0 ; \n while ( dong < n ) { \n printf ( \" \\ n \" ) ; \n cot = 1 ; \n while ( cot < = m ) { \n printf ( \" % u \\ t \" , dong + cot ) ; \n cot + + ; \n } \n dong + + ; \n } \n getch ( ) ; \n } \n Kết quả khi nhập 3 dòng 6 cột như sau : \n IV. 3 . Vòng lặp do … while \n Vòng lặp do … while giống như vòng lặp for , while , dùng \n để lặp lại một công việc nào đó trongkhi điều kiện còn đúng . \n Cú pháp : \n do \n < Công việc > \n while ( < Biểu thức điều kiện > )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 71}}
{"text": "Lập trình căn bản \n Lưu đồ : \n Giải thích : \n - < Công việc > : được thể hiện bằng 1 câu \n lệnh hay 1 khối lệnh . \n - Trước tiên công việc được thực hiện \n trước , sau đó mới kiểm tra điều kiện mới \n được kiểm tra . \n - Nếu điều kiện sai thì thoát khỏi lệnh do \n … while . \n - Nếu điều kiện còn đúng thì thực hiện \n công việc rồi quay lại kiểm tra điều kiện \n tiếp ... \n Lưu ý : \n - Lệnh do … while thực hiện công việc ít nhất 1 lần . \n - Vòng lặp dừng lại khi điều kiện sai . \n - Khối lệnh thực hiện công việc có thể rỗng , có thể làm \n thay đổi điều kiện . \n Thí dụ 1 : Viết chương trình in dãy số nguyên từ 1 đến 10 . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int i ; \n printf ( \" \\ n Day so tu 1 den 10 : \" ) ; \n i = 1 ; \n do { \n printf ( \" % d \" , i ) ; \n i + + ; \n } while ( i < = 10 ) ; \n getch ( ) ; \n } \n Kết quả chương trình như sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 72}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Viết chương trình nhập vào một số nguyên n . \n Tính tổng của các số nguyên từ 1 đến n . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int n , i , tong ; \n printf ( \" \\ n Nhap vao so nguyen duong n : \" ) ; \n scanf ( \" % u \" , & n ) ; \n tong = 0 ; \n i = 1 ; \n do { \n tong + = i ; \n i + + ; \n } while ( i < = n ) ; \n printf ( \" \\ n Tong tu 1 den % u = % u \" , n , tong ) ; \n getch ( ) ; \n } \n Nếu chúng ta nhập vào số 9 thì kết quả như sau : \n Thí dụ 3 : Viết chương trình in ra trên màn hình một ma \n trận có n dòng m cột như sau ( n , m > = 1 ) : \n 1 2 3 4 5 6 7 \n 2 3 4 5 6 7 8 \n 3 4 5 6 7 8 9 \n … \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int dong , cot , n , m ; \n printf ( \" \\ n Nhap vao so dong va so cot : \" ) ; \n scanf ( \" % u % u \" , & n , & m ) ; \n dong = 0 ; \n do { \n printf ( \" \\ n \" ) ; \n cot = 1 ; \n do {", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 73}}
{"text": "Lập trình căn bản \n printf ( \" % u \\ t \" , dong + cot ) ; \n cot + + ; \n } while ( cot < = m ) ; \n dong + + ; \n } while ( dong < n ) ; \n getch ( ) ; \n } \n Kết quả khi nhập 3 dòng 6 cột như sau \n IV. 4 . So sánh các vòng lặp \n Vòng lặp for , while : \n - Kiểm tra điều kiện trước thực hiện công việc sau nên \n đoạn lệnh thực hiện công việc có thể không được thực hiện . \n - Vòng lặp kết thúc khi điều kiện sai . \n Vòng lặp do … while : \n - Thực hiện công việc trước kiểm tra điều kiện sau nên \n đoạn lệnh thực hiện công việc được thực hiện ít nhất 1 lần . \n - Vòng lặp kết thúc khi điều kiện sai . \n V. CÁC CÂU LỆNH ĐẶC BIỆT \n V. 1 . Lệnh break \n Cú pháp : break ; \n Dùng để thoát khỏi vòng lặp . Khi gặp câu lệnh này trong \n vòng lặp , chương trình sẽ thoát ra khỏi vòng lặp và chỉ đến câu \n lệnh liền sau nó . Nếu nhiều vòng lặp thì break sẽ thoát ra khỏi \n vòng lặp gần nhất . \n Bên cạnh đó , break còn được dùng trong cấu trúc lựa chọn \n switch .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 74}}
{"text": "Lập trình căn bản \n Thí dụ : Viết chương trình nhập một số nguyên dương n từ \n bàn phím . Kiểm tra n có là số nguyên tố hay không ? \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n unsigned int n , i ; \n printf ( \" Nhap n = \" ) ; scanf ( \" % u \" , & n ) ; \n for ( i = 2 ; i < = n - 1 ; i + + ) \n if ( n % i = = 0 ) break ; \n if ( i = = n ) printf ( \" % u la so nguyen to \" , n ) ; \n else printf ( \" % u khong la so nguyen to \" , n ) ; \n getch ( ) ; \n } \n IV. 2 . Lệnh continue \n Cú pháp : continue ; \n - Khi gặp lệnh này trong các vòng lặp , chương trình sẽ bỏ \n qua phần còn lại trong vòng lặp và tiếp tục thực hiện lần lặp tiếp \n theo . \n - Ðối với lệnh for , biểu thức 3 sẽ được tính trị và quay lại \n bước 2 . \n - Ðối với lệnh while , do while ; biểu thức điều kiện sẽ được \n tính và xét xem có thể tiếp tục thực hiện < Công việc > nữa hay \n không ? ( dựa vào kết quả của biểu thức điều kiện ) . \n Thí dụ : Nhập vào một số nguyên dương n từ bàn phím . \n Hiển thị các số lẻ từ 1 đến n . \n # include < stdio . h > \n # include < conio . h > \n int main ( ) { \n unsigned int n , i ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 75}}
{"text": "đến n . \n # include < stdio . h > \n # include < conio . h > \n int main ( ) { \n unsigned int n , i ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 75}}
{"text": "Lập trình căn bản \n printf ( \" Nhap n = \" ) ; scanf ( \" % u \" , & n ) ; \n for ( i = 1 ; i < = n ; i + + ) { \n if ( i % 2 = = 0 ) continue ; \n printf ( \" % d \" , i ) ; \n } \n getch ( ) ; \n } \n VI. BÀI TẬP \n 1 . Viết chương trình nhập 3 số từ bàn phím , tìm số lớn nhất trong \n 3 số đó , in kết quả lên màn hình . \n 2 . Viết chương trình tính chu vi , diện tích của tam giác với yêu \n cầu sau khi nhập 3 số a , b , c phải kiểm tra lại xem a , b , c có tạo \n thành một tam giác không ? Nếu có thì tính chu vi và diện tích . \n Nếu không thì in ra câu \" Không tạo thành tam giác \" . \n 3 . Viết chương trình giải phương trình bậc nhất ax + b = 0 với a , b \n nhập từ bàn phím . \n 4 . Viết chương trình giải phương trình bậc hai ax2 + bx + c = 0 với \n a , b , c nhập từ bàn phím . \n 5 . Viết chương trình nhập từ bàn phím 2 số a , b và một ký tự ch . \n Nếu : ch là “ + “ thì thực hiện phép tính a + b và in kết \n quả lên màn hình . \n ch là “ – “ thì thực hiện phép tính a - b và in kết quả \n lên màn hình . \n ch là “ * ” thì thực hiện phép tính a * b và in kết \n quả lên màn hình . \n ch là “ / ” thì thực hiện phép tính a / b và in kết quả \n lên màn hình . \n 6 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 76}}
{"text": "ch là “ * ” thì thực hiện phép tính a * b và in kết \n quả lên màn hình . \n ch là “ / ” thì thực hiện phép tính a / b và in kết quả \n lên màn hình . \n 6 . Viết chương trình nhập vào 2 số là tháng và năm của một \n năm . Xét xem tháng đó có bao nhiêu ngày ? Biết rằng : \n Nếu tháng là 4 , 6 , 9 , 11 thì số ngày là 30 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 76}}
{"text": "Lập trình căn bản \n Nếu tháng là 1 , 3 , 5 , 7 , 8 , 10 , 12 thì số ngày là 31 . \n Nếu tháng là 2 và năm nhuận thì số ngày 29 , ngược lại thì \n số ngày là 28 . \n 7 . Viết chương trình tính tiền điện gồm các khoản sau : \n Tiền thuê bao điện kế : 1000 đồng / tháng . \n Định mức sử dụng điện cho mỗi hộ là 50 Kw \n Phần định mức tính giá 450 đồng / Kwh \n Nếu phần vượt định mức < = 50 Kw tính giá phạt cho phần \n này là 700 đồng / Kwh . \n Nếu phần vượt định mức lớn 50 Kw và nhỏ hơn 100Kw \n tính giá phạt cho phần này là 910 đồng / Kwh \n Nếu phần vượt định mức lớn hơn hay bằng 100 Kw tính \n giá phạt cho phần này là 1200 đồng / Kwh . \n Với : chỉ số điện kế cũ và chỉ số điện kế mới nhập vào từ \n bàn phím . In ra màn hình số tiền trả trong định mức , vượt định \n mức và tổng của chúng . \n 8 . Kiểm tra một ký tự nhập vào thuộc tập hợp nào trong các tập \n ký tự sau : \n Các ký tự chữ hoa : ' A ' ... ' Z ' \n Các ký tự chữ thường : ' a ' ... ' z ' \n Các ký tự chữ số : ' 0 ' ... ' 9 ' \n Các ký tự khác . \n 9 . Hệ thập lục phân dùng 16 ký số bao gồm các ký tự 0 và A , \n B , C , D , E , F.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 77}}
{"text": "9 . Hệ thập lục phân dùng 16 ký số bao gồm các ký tự 0 và A , \n B , C , D , E , F. \n Các ký số A , B , C , D , E , F có giá trị tương ứng trong hệ \n thập phân như sau : \n A 10 \n B 11 \n C 12 \n D 13 \n E 14 \n F 15 \n Hãy viết chương trình cho nhập vào ký tự biểu diễn một \n ký số của hệ thập lục phân và cho biết giá trị thập phân tương", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 77}}
{"text": "Lập trình căn bản \n ứng . Trường hợp ký tự nhập vào không thuộc các ký số trên , đưa \n ra thông báo lỗi : \n \" Hệ thập lục phân không dùng ký số này \" \n 10 . Viết chương trình nhập vào ngày tháng năm của ngày hôm \n nay , in ra ngày tháng năm của ngày mai . \n 11 . Viết chương trình tính các tổng sau : \n a ) S = 1 + 2 + ... + n \n b ) S = 1 / 2 + 2 / 3 + ... + n / ( n + 1 ) \n c ) S = - 1 + 2 - 3 + 4 - ... + ( - 1 ) nn \n 12 . Viết chương trình tính P = 2 * 4 * 6 * ... * ( 2n ) , n nhập từ bàn phím . \n 13 . Viết chương trình nhập vào một dãy n số , tìm số lớn nhất của \n dãy và xác định vị trí của số lớn nhất trong dãy . \n 14 . Tính giá trị trung bình của một dãy số thực nhập từ bàn phím , \n kết thúc dãy nhập khi nhập - 1 . \n 15 . Fibonacci là một dãy số được định nghĩa như sau : \n  1 , nnÕếuu n =  00 h hooặÆc = c n1  1 \n F n =  \n F  F , n  1 \n  \n n - 1 n  2 \n Viết chương trình in ra màn hình dãy Fibonacci có n số \n hạng , n nhập từ bàn phím khi cho chạy chương trình . \n 16 . Viết chương trình đếm số chữ số của một số nguyên n . \n 17 . Viết chương trình in ra số đảo ngược của một số nguyên n , \n với n nhập từ bàn phím . \n 18 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 78}}
{"text": "ơng trình đếm số chữ số của một số nguyên n . \n 17 . Viết chương trình in ra số đảo ngược của một số nguyên n , \n với n nhập từ bàn phím . \n 18 . Tìm số nguyên dương k nhỏ nhất sao cho 2k > n với n là một \n số nguyên dương nhập từ bàn phím . \n 19 . Viết chương trình mô phỏng phép chia nguyên DIV 2 số \n nguyên a và b như sau : để chia nguyên a và b ta tính trị a - b , sau \n đó lấy hiệu tìm được lại trừ cho b ... tiếp tục cho đến khi hiệu của \n nó nhỏ hơn b . Số lần thực hiện được các phép trừ ở trên sẽ bằng \n trị của phép chia nguyên . \n 20 . Tìm số nguyên dương N nhỏ nhất sao cho \n 1 + 1 / 2 + ... + 1 / N > S , với S nhập từ bàn phím . \n 21 . Viết chương trình tìm UCLN và BCNN của hai số a và b theo \n thuật toán sau ( Ký hiệu UCLN của a , b là ( a , b ) còn BCNN là \n [ a , b ] )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 78}}
{"text": "Lập trình căn bản \n - Nếu a chia hết cho b thì ( a , b ) = b \n - Nếu a = b * q + r thì ( a , b ) = ( b , r ) \n - [ a , b ] = a * b / ( b , r ) \n 22 . Viết chương trình nhập vào một số nguyên dương n , in ra \n màn hình các số nguyên tố p < = n . Số nguyên p gọi là số nguyên \n tố nếu p chỉ chia hết cho một và chia hết cho bản thân nó . \n 23 . Viết chương trình tính gần đúng căn bậc hai của một số \n dương a theo phương pháp Newton : \n Trước hết cho x = ( 1 + a ) / 2 sau đó là công thức truy hồi : \n 0 \n x = ( x + a / x ) / 2 \n n + 1 n n \n x - x \n Nếu : n + 1 n < e thì căn bậc hai của a bằng \n x \n n \n x \n Trong đó e là một hằng số cho trước làm độ chính xác . \n 24 . Viết chương trình tính gần đúng căn bậc n của một số dương \n a theo phương pháp Newton : \n Trước hết cho x = a / n sau đó là công thức truy hồi : \n 0 \n ( n - 1 ) x n + a \n x = k \n k + 1 \n nx n - 1 \n k \n Nếu | a - x n | < e thì x là căn bậc n của a . Trong đó e là một \n n n \n hằng số cho trước làm độ chính xác . Nếu a < 0 và n chẵn thì \n không tồn tại căn .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 79}}
{"text": "Lập trình căn bản \n Chương 5 \n CHƯƠNG TRÌNH CON ( HÀM ) \n Chương này trình bày về chương trình con ( hàm ) trong C. Các \n nội dung chính của chương này như sau : \n  Khái niệm về hàm ( function ) trong C. \n  Cách xây dựng và cách sử dụng hàm trong C. \n I. KHÁI NIỆM HÀM \n Trong những chương trình lớn , có thể có những đoạn chương \n trình viết lặp đi lặp lại nhiều lần , để tránh rườm rà và mất thời \n gian khi viết chương trình ; người ta thường phân chia chương \n trình thành nhiều module , mỗi module giải quyết một công việc \n nào đó . Các module như vậy gọi là các chương trình con . \n Một tiện lợi khác của việc sử dụng chương trình con là ta có thể \n dễ dàng kiểm tra xác định tính đúng đắn của nó trước khi ráp nối \n vào chương trình chính và do đó việc xác định sai sót để tiến \n hành hiệu đính trong chương trình chính sẽ thuận lợi hơn . \n Trong C , chương trình con được gọi là hàm . Hàm trong C có thể \n trả về kết quả thông qua tên hàm hay có thể không trả về kết quả . \n Hàm có hai loại : hàm chuẩn và hàm tự định nghĩa ( hàm người \n dùng ) . Trong chương này , ta chú trọng đến cách định nghĩa hàm \n và cách sử dụng các hàm đã được định nghĩa .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 80}}
{"text": "i : hàm chuẩn và hàm tự định nghĩa ( hàm người \n dùng ) . Trong chương này , ta chú trọng đến cách định nghĩa hàm \n và cách sử dụng các hàm đã được định nghĩa . \n Một hàm khi được định nghĩa thì có thể sử dụng bất cứ đâu trong \n chương trình . Để ý rằng trong C , một chương trình bắt đầu thực \n thi bằng hàm main . \n Thí dụ 1 : Ta có hàm max để tìm số lớn nhất giữa 2 số \n nguyên a , b như sau : \n int max ( int a , int b ) { \n return ( a > b ) ? a : b ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 80}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Ta có chương trình chính ( hàm main ) dùng để \n nhập vào 2 số nguyên a , b và in ra màn hình số lớn trong 2 số \n # include < stdio . h > \n # include < conio . h > \n int max ( int a , int b ) { \n return ( a > b ) ? a : b ; \n } \n main ( ) { \n int a , b , c ; \n printf ( \" \\ n Nhap vao 3 so a , b , c \" ) ; \n scanf ( \" % d % d % d \" , & a , & b , & c ) ; \n printf ( \" \\ n So lon la % d \" , max ( a , max ( b , c ) ) ) ; \n getch ( ) ; \n } \n I. 1 . Hàm chuẩn \n Hàm chuẩn là những hàm đã được định nghĩa sẵn trong \n một thư viện nào đó . Để sử dụng các hàm thư viện thì các thư \n viện định nghĩa chúng phải được tham chiếu đến nhờ chỉ thị tiền \n xử lý # include < tên thư viện . h > \n Một số thư viện thường dùng : \n 1 . stdio . h : Thư viện chứa các hàm vào / ra chuẩn \n ( standard input / output ) . Gồm các hàm printf ( ) , scanf ( ) , getc ( ) , \n putc ( ) , gets ( ) , puts ( ) , fflush ( ) , fopen ( ) , fclose ( ) , fread ( ) , \n fwrite ( ) , getchar ( ) , putchar ( ) , getw ( ) , putw ( ) … \n 2 . conio . h : Thư viện chứa các hàm vào ra trong chế độ \n DOS ( DOS console ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 81}}
{"text": ", getw ( ) , putw ( ) … \n 2 . conio . h : Thư viện chứa các hàm vào ra trong chế độ \n DOS ( DOS console ) . Gồm các hàm getch ( ) , getche ( ) , getpass ( ) , \n cgets ( ) , cputs ( ) , putch ( ) , , … \n 3 . math . h : Thư viện chứa các hàm tính toán gồm các hàm \n abs ( ) , sqrt ( ) , log ( ) . log10 ( ) , sin ( ) , cos ( ) , tan ( ) , acos ( ) , asin ( ) , \n atan ( ) , pow ( ) , exp ( ) , … \n 4 . malloc . h : Thư viện chứa các hàm liên quan đến việc \n quản lý bộ nhớ . Gồm các hàm calloc ( ) , realloc ( ) , malloc ( ) , \n free ( ) , farmalloc ( ) , farcalloc ( ) , farfree ( ) , …", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 81}}
{"text": "Lập trình căn bản \n 5 . io . h : Thư viện chứa các hàm vào ra cấp thấp . Gồm các \n hàm open ( ) ,  open ( ) , read ( ) ,  read ( ) , close ( ) ,  close ( ) , creat ( ) , \n  creat ( ) , creatnew ( ) , eof ( ) , filelength ( ) , lock ( ) , … \n … \n I. 2 . Hàm người dùng \n Hàm người dùng là những hàm do người lập trình tự tạo ra \n nhằm đáp ứng nhu cầu xử lý của mình . \n II. ĐỊNH NGHĨA VÀ SỬ DỤNG HÀM \n II. 1 Định nghĩa hàm \n Cấu trúc của một hàm tự thiết kế : \n < kiểu kết quả > Tên hàm ( [ < kiểu t số > < tham số > ] \n [ , < kiểu t số > < tham số > ] [ … ] ) \n { \n [ Khai báo biến cục bộ và các câu lệnh thực hiện hàm ] \n [ return [ < Biểu thức > ] ; ] \n } \n Giải thích : \n - Kiểu kết quả : là kiểu dữ liệu của kết quả trả về , có thể là : \n int , byte , char , float , void … Một hàm có thể có hoặc không có \n kết quả trả về . Trong trường hợp hàm không có kết quả trả về ta \n nên sử dụng kiểu kết quả là void . \n - Kiểu t số : là kiểu dữ liệu của tham số . \n - Tham số : là tham số truyền dữ liệu vào cho hàm , một \n hàm có thể có hoặc không có tham số . Tham số này gọi là tham \n số hình thức , khi gọi hàm chúng ta phải truyền cho nó các giá \n trị thực tế ( tham số thực tế ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 82}}
{"text": "vào cho hàm , một \n hàm có thể có hoặc không có tham số . Tham số này gọi là tham \n số hình thức , khi gọi hàm chúng ta phải truyền cho nó các giá \n trị thực tế ( tham số thực tế ) . Nếu có nhiều tham số , mỗi tham số \n phân cách nhau dấu phẩy ( , ) . \n - Bên trong thân hàm ( phần giới hạn bởi cặp dấu { } ) là các \n khai báo cùng các câu lệnh xử lý . Các khai báo bên trong hàm \n được gọi là các khai báo cục bộ trong hàm và các khai báo này \n chỉ tồn tại bên trong hàm mà thôi .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 82}}
{"text": "Lập trình căn bản \n - Khi định nghĩa hàm , ta thường sử dụng câu lệnh return \n để trả về kết quả thông qua tên hàm . \n Lệnh return dùng để thoát khỏi một hàm và có \n thể trả về một giá trị nào đó . \n Cú pháp : \n return ; / * không trả về giá trị * / \n return < biểu thức > ; / / Trả về giá trị của biểu thức \n return ( < biểu thức > ) ; / / Trả về giá trị của biểu thức \n Nếu hàm có kết quả trả về , ta bắt buộc phải sử dụng \n câu lệnh return để trả về kết quả cho hàm . \n Thí dụ 1 : Viết hàm tìm số lớn giữa 2 số nguyên a và b \n int max ( int a , int b ) { \n return ( a > b ) ? a : b ; \n } \n Thí dụ 2 : Viết hàm tìm ước chung lớn nhất giữa 2 số \n nguyên a , b . \n Cách tìm : đầu tiên ta giả sử UCLN của hai số là số nhỏ \n nhất trong hai số đó . Nếu điều đó không đúng thì ta giảm đi một \n đơn vị và cứ giảm như vậy cho tới khi nào tìm thấy UCLN. \n usigned int ucln ( unsigned int a , \n unsigned int b ) { \n unsgined int u ; \n if ( a < b ) \n u = a ; \n else \n u = b ; \n while ( ( a % u ! = 0 ) | | ( b % u ! = 0 ) ) \n u - - ; \n return u ; \n } \n II. 2 Sử dụng hàm \n Một hàm khi định nghĩa thì chúng vẫn chưa được thực thi \n trừ khi ta có một lời gọi đến hàm đó .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 83}}
{"text": "% u ! = 0 ) ) \n u - - ; \n return u ; \n } \n II. 2 Sử dụng hàm \n Một hàm khi định nghĩa thì chúng vẫn chưa được thực thi \n trừ khi ta có một lời gọi đến hàm đó .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 83}}
{"text": "Lập trình căn bản \n Cú pháp gọi hàm : < Tên hàm > ( [ Danh sách các tham số ] ) \n Thí dụ : Viết chương trình cho phép tìm ước số chung lớn \n nhất của hai số tự nhiên . \n # include < stdio . h > \n unsigned int ucln ( unsigned int a , \n unsigned int b ) \n { \n unsigned int u ; \n if ( a < b ) \n u = a ; \n else \n u = b ; \n while ( ( a % u ! = 0 ) | | ( b % u ! = 0 ) ) \n u - - ; \n return u ; \n } \n main ( ) { \n unsigned int A , B , UC ; \n printf ( “ Nhap a , b : ” ) ; scanf ( “ % u % u ” , & A , & B ) ; \n UC = ucln ( A , B ) ; \n printf ( “ Uoc chung lon nhat la : % u ” , UC ) ; \n } \n Lưu ý : \n - Khi 1 hàm có giá trị trả về , lời gọi hàm là một biểu thức , \n không phải là một câu lệnh . \n - Khi 1 hàm không có giá trị trả về ( void ) , lời gọi hàm \n được coi tương đương như 1 câu lệnh . \n II. 3 Nguyên tắc hoạt động của hàm \n Trong chương trình , khi gặp một lời gọi hàm thì hàm bắt \n đầu thực hiện bằng cách chuyển các lệnh thi hành đến hàm được \n gọi . Quá trình diễn ra như sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 84}}
{"text": "Lập trình căn bản \n - Nếu hàm có tham số , trước tiên các tham số sẽ được gán \n giá trị thực tế tương ứng ( giá trị thực tế chính là giá trị chỉ ra \n trong lời gọi hàm ) . \n - Chương trình sẽ thực hiện tiếp các câu lệnh trong thân \n hàm bắt đầu từ lệnh đầu tiên đến câu lệnh cuối cùng . \n Thí dụ : Lời gọi hàm ucln ( A , B ) trong hàm main ở trên : \n  A , B chính là các giá trị thực tế ( tham số thực tế ) . \n  a , b trong định nghĩa của hàm ucln ( dòng unsigned \n int ucln ( unsigned int a , unsigned int b ) ) \n là tham số hình thức . \n  Khi có lời gọi hàm ucln ( A , B ) thì a sẽ nhận giá trị \n của A , b sẽ nhận giá trị của B ; hàm ucln sẽ thực hiện \n từ đầu đến cuối hàm với các giá trị a , b đã nhận được . \n - Khi gặp lệnh return hoặc dấu } cuối cùng trong thân \n hàm , chương trình sẽ thoát khỏi hàm để trở về chương trình gọi \n nó và thực hiện tiếp tục những câu lệnh của chương trình này . \n III. TRUYỀN THAM SỐ CHO HÀM \n Mặc nhiên , việc truyền tham số cho hàm trong C là truyền \n theo giá trị ; nghĩa là tham số hình thức sẽ chỉ nhận giá trị là giá \n trị của tham số thực tế tương ứng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 85}}
{"text": "giá trị ; nghĩa là tham số hình thức sẽ chỉ nhận giá trị là giá \n trị của tham số thực tế tương ứng . Như vậy , về cơ bản tham số \n hình thức và tham số thực tế là hoàn toàn khác nhau ; do đó tham \n số thực tế không bị thay đổi giá trị sau khi hàm vừa được thực thi \n xong . \n Thí dụ 1 : Giả sử ta muốn in ra nhiều dòng , mỗi dòng 50 ký \n tự nào đó . Để đơn giản ta viết một hàm , nhiệm vụ của hàm này là \n in ra trên một dòng 50 ký tự nào đó . Hàm này có tên là InKT . \n # include < stdio . h > \n # include < conio . h > \n void InKT ( char ch ) { \n int i ; \n for ( i = 1 ; i < = 50 ; i + + ) \n printf ( “ % c ” , ch ) ; \n printf ( “ \\ n ” ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 85}}
{"text": "Lập trình căn bản \n main ( ) { \n char c ; \n InKT ( ‘ * ’ ) ; / / In ra 50 dau * \n InKT ( ‘ + ’ ) ; \n c = ‘ A ’ ; \n InKT ( c ) ; \n } \n Lưu ý : \n - Trong hàm InKT ở trên , biến ch gọi là tham số hình thức \n được truyền bằng giá trị ( gọi là tham trị của hàm ) . Các tham trị \n của hàm coi như là một biến cục bộ trong hàm và chúng được sử \n dụng như là dữ liệu đầu vào của hàm . \n - Khi chương trình con được gọi để thi hành , tham trị được \n cấp ô nhớ và nhận giá trị là bản sao giá trị của tham số thực . Do \n đó , mặc dù tham trị cũng là biến , nhưng việc thay đổi giá trị của \n chúng không có ý nghĩa gì đối với bên ngoài hàm , không ảnh \n hưởng đến chương trình chính , nghĩa là không làm ảnh hưởng \n đến tham số thực tương ứng . \n Thí dụ 2 : Xét chương trình sau đây : \n # include < stdio . h > \n # include < conio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 86}}
{"text": "main ( ) { \n int a , b ; \n printf ( \" \\ nNhap vao 2 so nguyen a , b : \" ) ; \n scanf ( \" % d % d \" , & a , & b ) ; \n printf ( \" \\ nTruoc khi goi ham hoan vi a = % d , \n b = % d \" , a , b ) ; \n hoanvi ( a , b ) ; \n printf ( \" \\ nSau khi goi ham hoan vi a = % d , \n b = % d \" , a , b ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 86}}
{"text": "Lập trình căn bản \n Kết quả thực hiện chương trình : \n Tương tự như thí dụ trên , các tham số thực tế ( a , b trong \n hàm main ) không thay đổi giá trị sau khi gọi hàm hoanvi . \n IV. HÀM ĐỆ QUY \n IV. 1 . Định nghĩa \n Một hàm được gọi là đệ quy nếu bên trong thân hàm có \n lệnh gọi đến chính nó . \n Thí dụ : Người ta định nghĩa giai thừa của một số nguyên \n dương n như sau : \n  1 , nÕu n  0 \n n ! =  \n  n * ( n - 1 ) ! , nÕu n  0 \n Với định nghĩa trên thì hàm đệ quy tính n ! được viết : \n long giaithua dequy ( int n ) { \n if ( n = = 0 ) \n return 1L ; \n else \n return n * giaithua dequy ( n - 1 ) ; \n } \n / * Hàm tính n ! không đệ quy * / \n long giaithua khongdequy ( int n ) { \n long kq ; \n int i ; \n kq = 1L ; \n for ( i = 1 ; i < = n ; i + + ) \n kq = kq * i ; \n return kq ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 87}}
{"text": "Lập trình căn bản \n main ( ) { \n int n ; \n printf ( \" Nhap so n = \" ) ; scanf ( \" % d \" , & n ) ; \n printf ( \" \\ nGoi ham de quy : % d ! = % ld \" , \n n , giaithua dequy ( n ) ) ; \n printf ( \" \\ nGoi ham khong de quy : % d ! = % ld \" , \n n , giaithua khongdequy ( n ) ) ; \n getch ( ) ; \n } \n IV. 2 . Lưu ý khi viết hàm đệ quy \n - Hàm đệ quy phải có 2 phần : \n o Phần dừng ( hay trường hợp nguyên tố ) . Trong thí dụ \n ở trên thì trường hợp n = 0 là trường hợp nguyên tố . \n o Phần đệ quy : là phần có gọi lại hàm đang được định \n nghĩa . Trong thí dụ trên thì phần đệ quy là n > 0 thì n ! = n * ( n - 1 ) ! \n - Sử dụng hàm đệ quy trong chương trình sẽ làm chương \n trình dễ đọc , dễ hiểu và vấn đề được nêu bật rõ ràng hơn . Tuy \n nhiên trong đa số trường hợp thì hàm đệ quy tốn bộ nhớ nhiều \n hơn và tốc độ thực hiện chương trình chậm hơn không đệ quy . \n - Tùy từng bài toán cụ thể mà người lập trình quyết định \n có nên dùng đệ quy hay không ( có những trường hợp không dùng \n đệ quy thì không giải quyết được bài toán ) . \n V. BÀI TẬP \n 1 . Viết hàm tìm số lớn nhất trong hai số . Áp dụng tìm số lớn nhất \n trong ba số a , b , c với a , b , c nhập từ bàn phím . \n 2 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 88}}
{"text": "quyết được bài toán ) . \n V. BÀI TẬP \n 1 . Viết hàm tìm số lớn nhất trong hai số . Áp dụng tìm số lớn nhất \n trong ba số a , b , c với a , b , c nhập từ bàn phím . \n 2 . Viết hàm tìm UCLN của hai số a và b . Áp dụng : Nhập vào tử \n và mẫu số của một phân số , kiểm tra xem phân số đó đã tối giản \n hay chưa . \n 3 . Viết hàm in n ký tự c trên một dòng . Viết chương trình cho \n nhập 5 số nguyên cho biết số lượng hàng bán được của mặt hàng \n A ở 5 cửa hàng khác nhau . Dùng hàm trên thể hiện biểu đồ so \n sánh 5 giá trị đó , mỗi trị dùng một ký tự riêng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 88}}
{"text": "Lập trình căn bản \n 4 . Viết một hàm tính tổng các chữ số của một số nguyên . Viết \n chương trình nhập vào một số nguyên , dùng hàm trên kiểm tra \n xem số đó có chia hết cho 3 không . Một số chia hết cho 3 khi \n tổng các chữ số của nó chia hết cho 3 . \n 5 . Viết chương trình phân tích một số nguyên dương n thành các \n thừa số nguyên tố . \n 6 . Viết chương trình tính các tổng sau : \n a ) S = 1 + x + x2 + x3 + ... + xn \n b ) S = 1 - x + x2 - x3 + ... ( - 1 ) n xn \n c ) S = 1 + x / 1 ! + x2 / 2 ! + x3 / 3 ! + ... + xn / n ! \n Trong đó n là một số nguyên dương và x là một số bất kỳ \n được nhập từ bàn phím khi chạy chương trình . \n 7 . Tam giác Pascal là một bảng số , trong đó hàng thứ 0 bằng 1 , \n mỗi một số hạng của hàng thứ n + 1 là một tổ hợp chập k của n \n n ! \n ( Ck = ) \n n k ! ( n  k ) ! \n Tam giác Pascal có dạng sau : \n 1 ( hàng 0 ) \n 1 1 ( hàng 1 ) \n 1 2 1 ( hàng 2 ) \n 1 3 3 1 \n 1 4 6 4 1 \n 1 5 10 10 5 1 \n 1 6 15 20 15 6 1 ( hàng 6 ) \n ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... \n Viết chương trình hiển thị lên màn hình tam giác Pascal có \n n hàng ( n nhập vào khi chạy chương trình ) bằng cách tạo hai hàm \n tính giai thừa và tính tổ hợp . \n 8 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 89}}
{"text": ".. ... ... ... ... ... ... \n Viết chương trình hiển thị lên màn hình tam giác Pascal có \n n hàng ( n nhập vào khi chạy chương trình ) bằng cách tạo hai hàm \n tính giai thừa và tính tổ hợp . \n 8 . Yêu cầu như câu 7 nhưng dựa công thức truy hồi của tổ hợp \n mà viết thành 1 hàm đệ quy để tính số tổ hợp chập k của n phần \n tử . \n  1 , nÕu k  0 hoÆc k  n \n Ck   \n n Ck - 1  Ck , nÕu 1  k  n \n  \n n - 1 n - 1", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 89}}
{"text": "Lập trình căn bản \n 9 . Viết chương trình in dãy Fibonacci đã nêu trong bằng phương \n pháp dùng một hàm Fibonacci F có tính đệ quy . \n  1 , nÕu n  0 hoÆc n  1 \n F n =  \n F  F , nÕu n  1 \n  \n n - 2 n - 1 \n 10 . Bài toán tháp Hà Nội : Có một cái tháp gồm n tầng , tầng trên \n nhỏ hơn tầng dưới ( hình vẽ ) . Hãy tìm cách chuyển cái tháp này từ \n vị trí thứ nhất sang vị trí thứ hai thông qua vị trí trung gian thứ \n ba . Biết rằng chỉ được chuyển mỗi lần một tầng và không được \n để tầng lớn trên tầng nhỏ . \n VT1 VT2 VT3", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 90}}
{"text": "Lập trình căn bản \n Chương 6 \n MẢNG \n Chương này trình bày về kiểu dữ liệu mảng - một kiểu dữ liệu có \n cấu trúc được sử dụng phổ biến khi lập trình . Nội dung chính của \n chương này gồm : \n  Khái niệm về kiểu dữ liệu mảng cũng như ứng dụng của \n kiểu dữ liệu này . \n  Cách khai báo biến kiểu mảng và các phép toán trên các \n phần tử của mảng . \n I. GIỚI THIỆU KIỂU DỮ LIỆU MẢNG TRONG C \n Mảng là một tập hợp các phần tử cố định có cùng một kiểu , gọi là \n kiểu phần tử . Kiểu phần tử có thể là có các kiểu bất kỳ : ký tự , số , \n chuỗi ký tự … ; cũng có khi ta sử dụng kiểu mảng để làm kiểu \n phần tử cho một mảng ( trong trường hợp này ta gọi là mảng của \n mảng hay mảng nhiều chiều ) . \n Ta có thể chia mảng làm 2 loại : mảng 1 chiều và mảng nhiều \n chiều . \n Mảng là kiểu dữ liệu được sử dụng rất thường xuyên . Chẳng hạn \n người ta cần quản lý một danh sách họ và tên của khoảng 100 \n sinh viên trong một lớp . Nhận thấy rằng mỗi họ và tên để lưu trữ \n ta cần 1 biến kiểu chuỗi , như vậy 100 họ và tên thì cần khai báo \n 100 biến kiểu chuỗi . Nếu khai báo như thế này thì đoạn khai báo \n cũng như các thao tác trên các họ tên sẽ rất dài dòng và rắc rối .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 91}}
{"text": "ọ và tên thì cần khai báo \n 100 biến kiểu chuỗi . Nếu khai báo như thế này thì đoạn khai báo \n cũng như các thao tác trên các họ tên sẽ rất dài dòng và rắc rối . \n Vì thế , kiểu dữ liệu mảng giúp ích ta trong trường hợp này ; chỉ \n cần khai báo 1 biến , biến này có thể coi như là tương đương với \n 100 biến chuỗi ký tự ; đó là 1 mảng mà các phần tử của nó là \n chuỗi ký tự . Hoặc 1 thí dụ khác là việc lưu trữ các từ khóa của \n ngôn ngữ lập trình C , ta cũng có thể dùng đến một mảng để lưu \n trữ chúng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 91}}
{"text": "Lập trình căn bản \n II. MẢNG 1 CHIỀU \n Xét dưới góc độ toán học , mảng 1 chiều giống như một vector . \n Mỗi phần tử của mảng một chiều có giá trị không phải là một \n mảng khác . \n II. 1 . Khai báo \n II. 1.1 . Khai báo mảng với số phần tử xác định ( khai báo tường \n minh ) \n Cú pháp : < Kiểu > < Tên mảng > < [ số phần tử ] > \n Ý nghĩa : \n - Tên mảng : đây là một tên đặt đúng theo quy tắc đặt tên \n của danh biểu . Tên này cũng mang ý nghĩa là tên biến mảng . \n - Số phần tử : là một hằng số nguyên , cho biết số lượng \n phần tử tối đa trong mảng là bao nhiêu ( hay nói khác đi kích \n thước của mảng là gì ) . \n - Kiểu : mỗi phần tử của mảng có dữ liệu thuộc kiểu gì . \n - Ở đây , ta khai báo một biến mảng gồm có số phần tử \n phần tử , phần tử thứ nhất là tên mảng [ 0 ] , phần tử cuối cùng là \n tên mảng [ số phần tử - 1 ] \n Thí dụ : \n int a [ 10 ] ; / * Khai báo biến mảng tên a , phần tử \n thứ nhất là a [ 0 ] , phần tử cuối cùng là a [ 9 ] . * / \n  Ta có thể coi mảng a là một dãy liên tiếp các \n phần tử trong bộ nhớ như sau : \n Vị trí 0 1 2 3 4 5 6 7 8 9\n\nTên phần tử a [ 0 ] a [ 1 ] a [ 2 ] a [ 3 ] a [ 4 ] a [ 5 ] a [ 6 ] a [ 7 ] a [ 8 ] a [ 9 ] \n II. 1.2 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 92}}
{"text": "c \n phần tử trong bộ nhớ như sau : \n Vị trí 0 1 2 3 4 5 6 7 8 9\n\nTên phần tử a [ 0 ] a [ 1 ] a [ 2 ] a [ 3 ] a [ 4 ] a [ 5 ] a [ 6 ] a [ 7 ] a [ 8 ] a [ 9 ] \n II. 1.2 . Khai báo mảng với số phần tử không xác định ( khai báo \n không tường minh ) \n Cú pháp : < Kiểu > < Tên mảng > < [ ] > \n Khi khai báo , không cho biết rõ số phần tử của mảng , kiểu \n khai báo này thường được áp dụng trong các trường hợp : vừa", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 92}}
{"text": "Lập trình căn bản \n khai báo vừa gán giá trị , khai báo mảng là tham số hình thức của \n hàm . \n a . Vừa khai báo vừa gán giá trị \n Cú pháp : \n < Kiểu > < Tên mảng > [ ] = { Các giá trị cách nhau \n bởi dấu phẩy } ; \n Nếu vừa khai báo vừa gán giá trị thì mặc nhiên C sẽ hiểu \n số phần tử của mảng là số giá trị mà chúng ta gán cho mảng \n trong cặp dấu { } . Chúng ta có thể sử dụng hàm sizeof ( ) để lấy \n số phần tử của mảng như sau : \n Số phần tử = sizeof ( tên mảng ) / sizeof ( kiểu ) \n b . Khai báo mảng là tham số hình thức của hàm , trong \n trường hợp này ta không cần chỉ định cụ thể số phần tử của \n mảng . \n II. 2 Truy xuất từng phần tử của mảng \n Mỗi phần tử của mảng được truy xuất thông qua Tên biến \n mảng theo sau là chỉ số nằm trong cặp dấu ngoặc vuông [ ] . \n Chẳng hạn a [ 0 ] là phần tử đầu tiên của mảng a được khai báo ở \n trên . Chỉ số của phần tử mảng là một biểu thức mà giá trị là kiểu \n số nguyên . \n Với cách truy xuất theo kiểu này , Tên biến mảng [ Chỉ số ] \n có thể coi như là một biến có kiểu dữ liệu là kiểu được chỉ ra \n trong khai báo biến mảng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 93}}
{"text": "ư là một biến có kiểu dữ liệu là kiểu được chỉ ra \n trong khai báo biến mảng . \n Thí dụ 1 : \n int a [ 10 ] ; \n - Phần tử đầu tiên trong mảng là a [ 0 ] \n - Phần tử kế tiếp trong mảng là a [ 1 ] \n … \n - Phần tử cuối cùng trong mảng là a [ 9 ] .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 93}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Vừa khai báo vừa gán trị cho 1 mảng 1 chiều các \n số nguyên . In mảng số nguyên này lên màn hình . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n int n , i ; \n int dayso [ ] = { 66,65,69,68,67,70 } ; \n n = sizeof ( dayso ) / sizeof ( int ) ; / / số phần tử \n printf ( \" \\ n Noi dung cua mang \" ) ; \n for ( i = 0 ; i < n ; i + + ) \n printf ( \" % d \" , dayso [ i ] ) ; \n } \n Thí dụ 3 : Đổi một số nguyên dương thập phân thành số \n nhị phân . Việc chuyển đổi này được thực hiện bằng cách lấy số \n đó chia liên tiếp cho 2 cho tới khi bằng 0 và lấy các số dư theo \n chiều ngược lại để tạo thành số nhị phân . Trong thí dụ này , mảng \n một chiều được sử dụng để lưu lại các số dư đó . Chương trình cụ \n thể như sau : \n # include < conio . h > \n # include < stdio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 94}}
{"text": "an [ K ] = Du ; / / Lưu số dư vào mảng ở vị trí K \n K + + ; / / Tăng K lên để lần kế lưu vào vị trí kế \n N = N / 2 ; \n } while ( N > 0 ) ; \n printf ( \" Dang nhi phan la : \" ) ; \n for ( i = K - 1 ; i > = 0 ; i - - ) \n printf ( \" % u \" , NhiPhan [ i ] ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 94}}
{"text": "Lập trình căn bản \n Thí dụ 4 : Nhập vào một dãy n số và sắp xếp các số theo \n thứ tự tăng . \n Bài toán sắp xếp là 1 bài toán có ứng dụng rộng rãi trong \n nhiều lĩnh vực . Để sắp xếp một dãy n số , có rất nhiều giải thuật \n để thực hiện . Một trong số đó được mô tả như sau : \n Đầu tiên đưa phần tử thứ nhất so sánh với các phần tử còn \n lại , nếu nó lớn hơn một phần tử đang so sánh thì đổi chỗ hai phần \n tử cho nhau . Sau đó tiếp tục so sánh phần tử thứ hai với các phần \n tử từ thứ ba trở đi ... cứ tiếp tục như vậy cho đến phần tử thứ n - 1 . \n Chương trình sẽ được chia thành các hàm Nhap ( Nhập các \n số ) , SapXep ( Sắp xếp ) và InMang ( In các số ) ; các tham số hình \n thức của các hàm này là 1 mảng không chỉ định rõ số phần tử tối \n đa , nhưng ta cần có thêm số phần tử thực tế được sử dụng của \n mảng là bao nhiêu , đây là một giá trị nguyên . \n # include < conio . h > \n # include < stdio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 95}}
{"text": "Phan tu thu % d : \" , i ) ; \n scanf ( \" % d \" , & a [ i ] ) ; \n } \n } \n void InMang ( int a [ ] , int N ) { \n int i ; \n for ( i = 0 ; i < N ; i + + ) \n printf ( \" % d \" , a [ i ] ) ; \n printf ( \" \\ n \" ) ; \n } \n void SapXep ( int a [ ] , int N ) { \n int t , i , j ; \n for ( i = 0 ; i < N - 1 ; i + + ) \n for ( j = i + 1 ; j < N ; j + + ) \n if ( a [ i ] > a [ j ] ) { \n t = a [ i ] ; \n a [ i ] = a [ j ] ; \n a [ j ] = t ; \n } \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 95}}
{"text": "Lập trình căn bản \n main ( ) { \n int b [ 20 ] , N ; \n printf ( \" So phan tu thuc te N = \" ) ; \n scanf ( \" % d \" , & N ) ; \n Nhap ( b , N ) ; \n printf ( \" Mang vua nhap : \" ) ; \n InMang ( b , N ) ; \n SapXep ( b , N ) ; / / Gọi hàm sắp xếp \n printf ( \" Mang sau khi sap xep : \" ) ; \n InMang ( b , N ) ; \n getch ( ) ; \n } \n Kết quả chạy chương trình có thể là : \n III. MẢNG NHIỀU CHIỀU \n Mảng nhiều chiều là 1 mảng mà mỗi phần tử của mảng là 1 mảng \n khác . \n Người ta thường sử dụng mảng nhiều chiều để lưu các ma trận , \n các tọa độ 2 chiều , 3 chiều … \n Phần dưới đây là các vấn đề liên quan đến mảng 2 chiều ; các \n mảng 3 , 4 , … chiều thì tương tự ( chỉ cần tổng quát hóa lên ) . \n III. 1 Khai báo \n III. 1.1 . Khai báo mảng 2 chiều tường minh \n Cú pháp : \n < Kiểu > < Tên mảng > < [ Số phần tử chiều 1 ] > < [ Số phần tử chiều 2 ] >", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 96}}
{"text": "Lập trình căn bản \n Thí dụ : Người ta cần lưu trữ thông tin của một ma trận \n gồm các số thực . Lúc này ta có thể khai báo một mảng 2 chiều \n như sau : \n float m [ 5 ] [ 6 ] ; / / Khai báo mảng 2 chiều có 5 * 6 \n phần tử là số thực \n Trong trường hợp này , ta đã khai báo cho một ma trận có \n tối đa là 5 dòng , mỗi dòng có tối đa là 6 cột . Hình ảnh của ma \n trận này được thể hiện trong hình bên dưới : \n Dòng \\ Cột 0 1 2 3 4 5\n\n| m[0][0] | m[0][1] | m[0][2] | m[0][3] | m[0][4] | m[0][5] |\n| --- | --- | --- | --- | --- | --- |\n| m[1][0] | m[1][1] | m[1][2] | m[1][3] | m[1][4] | m[1][5] |\n| m[2][0] | m[2][1] | m[2][2] | m[2][3] | m[2][4] | m[2][5] |\n| m[3][0] | m[3][1] | m[3][2] | m[3][3] | m[3][4] | m[3][5] |\n| m[4][0] | m[4][1] | m[4][2] | m[4][3] | m[4][4] | m[4][5] |\n\n\nIII. 1.2 . Khai báo mảng 2 chiều không tường minh \n Để khai báo mảng 2 chiều không tường minh , ta vẫn phải \n chỉ ra số phần tử của chiều thứ hai ( chiều cuối cùng ) . \n Cú pháp : \n < Kiểu > < Tên mảng > < [ ] > < [ Số phần tử chiều 2 ] > \n Cách khai báo này cũng được áp dụng trong trường hợp \n vừa khai báo , vừa gán trị hay đặt mảng 2 chiều là tham số hình \n thức của hàm . \n III.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 97}}
{"text": "phần tử chiều 2 ] > \n Cách khai báo này cũng được áp dụng trong trường hợp \n vừa khai báo , vừa gán trị hay đặt mảng 2 chiều là tham số hình \n thức của hàm . \n III. 2 Truy xuất từng phần tử của mảng 2 chiều \n Ta có thể truy xuất một phần tử của mảng hai chiều bằng \n cách viết ra tên mảng theo sau là hai chỉ số đặt trong hai cặp dấu \n ngoặc vuông . Chẳng hạn ta viết m [ 2 ] [ 3 ] . \n Với cách truy xuất theo cách này , Tên mảng [ Chỉ số \n 1 ] [ Chỉ số 2 ] có thể coi là 1 biến có kiểu được chỉ ra trong khai \n báo biến mảng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 97}}
{"text": "Lập trình căn bản \n Thí dụ 1 : Viết chương trình cho phép nhập 2 ma trận a , b \n có m dòng n cột , thực hiện phép toán cộng hai ma trận a , b và in \n ma trận kết quả lên màn hình . \n Trong thí dụ này , ta sẽ sử dụng hàm để chương trình ngắn \n gọn hơn . Trong trường hợp này , các hàm sau được định nghĩa : \n nhập 1 ma trận từ bàn phím , hiển thị ma trận lên màn hình , cộng \n 2 ma trận . \n # include < conio . h > \n # include < stdio . h > \n void Nhap ( float a [ ] [ 10 ] , int M , int N ) { \n int i , j ; \n for ( i = 0 ; i < M ; i + + ) \n for ( j = 0 ; j < N ; j + + ) { \n printf ( \" Phan tu o dong % d cot % d : \" , i , j ) ; \n scanf ( \" % f \" , & a [ i ] [ j ] ) ; \n } \n } \n void InMaTran ( float a [ ] [ 10 ] , int M , int N ) { \n int i , j ; \n for ( i = 0 ; i < M ; i + + ) \n { \n for ( j = 0 ; j < N ; j + + ) \n printf ( \" % .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 98}}
{"text": "int M , int N , float c [ ] [ 10 ] ) \n { \n int i , j ; \n for ( i = 0 ; i < M ; i + + ) \n for ( j = 0 ; j < N ; j + + ) \n c [ i ] [ j ] = a [ i ] [ j ] + b [ i ] [ j ] ; \n } \n main ( ) \n { \n float a [ 10 ] [ 10 ] , b [ 10 ] [ 10 ] , c [ 10 ] [ 10 ] ; \n int M , N ; \n printf ( \" So dong M = \" ) ; scanf ( \" % d \" , & M ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 98}}
{"text": "Lập trình căn bản \n printf ( \" So cot M = \" ) ; scanf ( \" % d \" , & N ) ; \n printf ( \" Nhap ma tran A \\ n \" ) ; \n Nhap ( a , M , N ) ; \n printf ( \" Nhap ma tran B \\ n \" ) ; \n Nhap ( b , M , N ) ; \n printf ( \" Ma tran A : \\ n \" ) ; \n InMaTran ( a , M , N ) ; \n printf ( \" Ma tran B : \\ n \" ) ; \n InMaTran ( b , M , N ) ; \n CongMaTran ( a , b , M , N , c ) ; \n printf ( \" Ma tran tong C : \\ n \" ) ; \n InMaTran ( c , M , N ) ; \n getch ( ) ; \n } \n Thí dụ 2 : Nhập vào một ma trận 2 chiều gồm các số thực , \n in ra tổng của các phần tử trên đường chéo chính của ma trận \n này . \n Ta nhận thấy rằng nếu ma trận a có M dòng , N cột thì các \n phần tử của đường chéo chính là các phần tử có dạng : a [ i ] [ i ] với i \n  [ 1 … min ( M , N ) ] . \n # include < conio . h > \n # include < stdio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 99}}
{"text": "i + + ) \n for ( j = 0 ; j < N ; j + + ) { \n printf ( \" Phan tu ( % d , % d ) : \" , i , j ) ; \n scanf ( \" % f \" , & a [ i ] [ j ] ) ; \n } \n printf ( \" Ma tran vua nhap : \\ n \" ) ; \n for ( i = 0 ; i < M ; i + + ) { \n for ( j = 0 ; j < N ; j + + ) \n printf ( \" % . 2f \" , a [ i ] [ j ] ) ; \n printf ( \" \\ n \" ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 99}}
{"text": "Lập trình căn bản \n } \n T = 0.0 ; \n Min = ( M > N ) ? N : M ; / * Tìm giá trị nhỏ nhất \n của M & N * / \n for ( i = 0 ; i < Min ; i + + ) \n T = T + a [ i ] [ i ] ; \n printf ( \" Tong cac phan tu o duong cheo \n chinh la : % . 2f \" , T ) ; \n getch ( ) ; \n } \n IV. BÀI TẬP \n 1 . Viết chương trình nhập vào một dãy n số thực a [ 0 ] , a [ 1 ] , ... , \n a [ n - 1 ] , sắp xếp dãy số theo thứ tự giảm dần . In dãy số sau khi sắp \n xếp . \n 2 . Giả sử mảng a ban đầu đã được sắp thứ tự tăng dần . Viết \n chương trình cho phép loại bỏ các phần tử trùng nhau trong mảng \n a . \n Thí dụ : Mảng a - 1 0 0 2 2 3 \n Mảng sau khi loại các phần tử trùng nhau : \n - 1 0 2 3 \n 3 . Viết chương trình nhập vào một mảng , hãy xuất ra màn hình : \n - Phần tử lớn nhất của mảng . \n - Phần tử nhỏ nhất của mảng . \n - Tính tổng của các phần tử trong mảng . \n - Tính tổng bình phương các số âm trong mảng . \n 4 . Viết chương trình nhập vào một mảng số tự nhiên . Hãy xuất ra \n màn hình : \n - Dòng 1 : gồm các số lẻ , tổng cộng có bao nhiêu số lẻ . \n - Dòng 2 : gồm các số chẵn , tổng cộng có bao nhiêu số chẵn . \n - Dòng 3 : gồm các số nguyên tố , tổng cộng có bao nhiêu \n số nguyên tố .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 100}}
{"text": "ao nhiêu số lẻ . \n - Dòng 2 : gồm các số chẵn , tổng cộng có bao nhiêu số chẵn . \n - Dòng 3 : gồm các số nguyên tố , tổng cộng có bao nhiêu \n số nguyên tố .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 100}}
{"text": "Lập trình căn bản \n - Dòng 4 : gồm các số không phải là số nguyên tố , tổng \n cộng có bao nhiêu số không nguyên tố . \n 5 . Viết chương trình thực hiện việc đảo một mảng một chiều . \n Thí dụ : 1 2 3 4 5 7 9 đảo thành 9 7 5 4 3 2 1 . \n 6 . Viết chương trình nhập vào một dãy các số theo thứ tự tăng , \n nếu nhập sai quy cách thì yêu cầu nhập lại . In dãy số sau khi đã \n nhập xong . Nhập thêm một số mới và chèn số đó vào dãy đã có \n sao cho dãy vẫn đảm bảo thứ tự tăng . In lại dãy số để kiểm tra . \n 7 . Viết chương trình thực hiện việc trộn hai mảng có thứ tự thành \n một mảng có thứ tự . Yêu cầu không được gộp 2 mảng lại rồi mới \n sắp thứ tự nhờ vào 1 hàm sắp xếp . \n 8 . Viết chương trình nhập vào một ma trận ( mảng hai chiều ) các \n số nguyên , gồm m hàng , n cột . In ma trận đó lên màn hình . Nhập \n một số nguyên khác vào và xét xem có phần tử nào của ma trận \n trùng với số này không ? Ở vị trí nào ? Có bao nhiêu phần tử ? \n 9 . Viết chương trình để chuyển đổi vị trí từ dòng thành cột của \n một ma trận ( ma trận chuyển vị ) vuông 4 hàng 4 cột .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 101}}
{"text": "một ma trận ( ma trận chuyển vị ) vuông 4 hàng 4 cột . \n Thí dụ : \n 1 2 3 4 1 2 9 1 \n 2 5 5 8 2 5 4 5 \n 9 4 2 0 3 5 2 8 \n 1 5 8 6 4 8 0 6 \n Viết chương trình cho ma trận trong trưởng hợp tổng quát \n ( cấp m * n : m dòng , n cột ) . \n 10 . Viết chương trình nhập vào hai ma trận A có cấp m , k và B \n có cấp k , n . In hai ma trận lên màn hình . Tích hai ma trận A và B \n là ma trận C được tính bởi công thức : \n c = a * b + a * b + a * b + ... + a * b \n ij i1 1j i2 2j i3 3j ik kj \n ( i = 0,1,2 , ... m - 1 ; j = 0,1,2 ... n - 1 ) \n Tính ma trận tích C và in kết quả lên màn hình . \n 11 . Xét ma trận A vuông cấp n , các phần tử a [ i , i ] ( i = 1 ... n ) \n được gọi là đường chéo chính của ma trận vuông A. Ma trận", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 101}}
{"text": "Lập trình căn bản \n vuông A được gọi là ma trận tam giác nếu tất cả các phần tử dưới \n đường chéo chính đều bằng 0 . Định thức của ma trận tam giác \n bằng tích các phần tử trên đường chéo chính . \n Ta có thể chuyển một ma trận vuông bất kỳ về ma trận tam giác \n bằng thuật toán : \n - Xét cột i ( i = 0,1 ... n - 2 ) \n - Trong cột i xét các phần tử a [ k , i ] ( k = i + 1 ... n - 1 ) \n + Nếu a [ k , i ] = 0 thì tăng k lên xét phần tử khác \n + Nếu a [ k , i ] < > 0 thì làm như sau : \n Nhân toàn bộ hàng k với - a [ i , i ] / a [ k , i ] \n Lấy hàng k cộng vào hàng i sau khi thực hiện phép \n nhân trên . \n Đổi chỗ hai hàng i và k cho nhau \n Nhân toàn bộ hàng k với - 1 sau khi đã đổi chỗ với \n hàng i \n Tăng k lên xét phần tử khác . \n Viết chương trình tính định thức cấp n thông qua các bước nhập \n ma trận , in ma trận , đưa ma trận về dạng tam giác , in ma trận tam \n giác , in kết quả tính định thức .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 102}}
{"text": "Lập trình căn bản \n Chương 7 \n CON TRỎ \n Các vấn đề được trình bày trong chương này : \n  Khái niệm về kiểu dữ liệu “ con trỏ ” . \n  Cách khai báo và cách sử dụng biến kiểu con trỏ . \n  Mối quan hệ giữa mảng và con trỏ . \n I. GIỚI THIỆU KIỂU DỮ LIỆU CON TRỎ \n Các biến chúng ta đã biết và sử dụng trước đây đều là biến có \n kích thước và kiểu dữ liệu xác định . Người ta gọi các biến kiểu \n này là biến tĩnh . Khi khai báo biến tĩnh , một lượng ô nhớ cho các \n biến này sẽ được cấp phát mà không cần biết trong quá trình thực \n thi chương trình có sử dụng hết lượng ô nhớ này hay không . Mặt \n khác , các biến tĩnh dạng này sẽ tồn tại trong suốt thời gian thực \n thi chương trình dù có những biến mà chương trình chỉ sử dụng 1 \n lần rồi bỏ . \n Do đó , một số vấn đề có thể gặp phải khi sử dụng các biến \n tĩnh : \n o Cấp phát ô nhớ dư , gây ra lãng phí ô nhớ . \n o Cấp phát ô nhớ thiếu , chương trình thực thi bị lỗi . \n Để tránh những hạn chế trên , người lập trình được cung cấp một \n loại biến đặc biệt gọi là biến động với các đặc điểm sau : \n o Chỉ phát sinh trong quá trình thực hiện chương trình \n chứ không phát sinh lúc bắt đầu chương trình .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 103}}
{"text": "c biệt gọi là biến động với các đặc điểm sau : \n o Chỉ phát sinh trong quá trình thực hiện chương trình \n chứ không phát sinh lúc bắt đầu chương trình . \n o Khi chạy chương trình , kích thước của biến , vùng nhớ \n và địa chỉ vùng nhớ được cấp phát cho biến có thể thay đổi . \n o Sau khi sử dụng xong có thể giải phóng để tiết kiệm \n chỗ trong bộ nhớ . \n Tuy nhiên một số ngôn ngữ lập trình chẳng hạn như C không \n cung cấp 1 cách thức trực tiếp để thao tác với biến động . Vì thế ,", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 103}}
{"text": "Lập trình căn bản \n ngôn ngữ C cung cấp cho ta một loại biến đặc biệt là biến con trỏ \n ( pointer ) với các đặc điểm : \n o Biến con trỏ không chứa dữ liệu mà chỉ chứa địa chỉ \n của dữ liệu hay chứa địa chỉ của ô nhớ chứa dữ liệu . Lúc đó ô \n nhớ chứa dữ liệu có thể coi như là 1 biến động . \n o Kích thước của biến con trỏ không phụ thuộc vào kiểu \n dữ liệu , luôn có kích thước cố định là 2 byte ( giá trị nguyên để \n chứa địa chỉ ) . \n Như vậy thực chất vai trò của biến con trỏ chính là hỗ trợ cho \n người lập trình cách thức thao tác với các biến động . \n II. KHAI BÁO VÀ SỬ DỤNG BIẾN CON TRỎ \n II. 1 . Khai báo biến con trỏ \n Cú pháp : < Kiểu > * < Tên con trỏ > \n Ý nghĩa : Khai báo một biến có tên là Tên con trỏ dùng để \n chứa địa chỉ của các biến có kiểu Kiểu . \n Thí dụ 1 : Khai báo 2 biến a , b có kiểu int và 2 biến pa , pb \n là 2 biến con trỏ kiểu int . \n int a , b , * pa , * pb ; \n Thí dụ 2 : Khai báo biến f kiểu float và biến pf là con trỏ \n float \n float f , * pf ; \n Ghi chú : Nếu chưa muốn khai báo kiểu dữ liệu mà con trỏ \n ptr đang chỉ đến , ta sử dụng con trỏ void : \n void * ptr ; \n Sau đó , nếu ta muốn con trỏ ptr chỉ đến kiểu dữ liệu gì \n cũng được .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 104}}
{"text": "chưa muốn khai báo kiểu dữ liệu mà con trỏ \n ptr đang chỉ đến , ta sử dụng con trỏ void : \n void * ptr ; \n Sau đó , nếu ta muốn con trỏ ptr chỉ đến kiểu dữ liệu gì \n cũng được . Tác dụng của khai báo này là chỉ dành ra 2 bytes \n trong bộ nhớ để cấp phát cho biến con trỏ ptr .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 104}}
{"text": "Lập trình căn bản \n II. 2 . Các thao tác trên con trỏ \n II. 2.1 Gán địa chỉ của biến cho biến con trỏ \n Toán tử & dùng để trả về địa chỉ của 1 biến ( định vị con \n trỏ đến địa chỉ của một biến ) . \n Cú pháp : < Tên biến con trỏ > = & < Tên biến > \n Giải thích : Ta gán địa chỉ của biến Tên biến cho con trỏ \n Tên biến con trỏ . \n Thí dụ : Gán địa chỉ của biến a cho con trỏ pa , gán địa chỉ \n của biến b cho con trỏ pb . \n pa = & a ; pb = & b ; \n Lúc này , hình ảnh của các biến trong bộ nhớ được mô tả :\n\n| a | b |\n| --- | --- |\n\n\npa pb 2 2 \n byte byte \n Lưu ý : \n Khi gán địa chỉ của 1 biến cho 1 con trỏ cần phải lưu ý \n kiểu dữ liệu của chúng . Ví dụ sau đây không đúng do không \n tương thích kiểu : \n int Bien Nguyen ; \n float * Con Tro Thuc ; \n ... \n Con Tro Thuc = & Bien Nguyen ; \n Phép gán ở đây là sai vì Con Tro Thuc là một con trỏ \n kiểu float ( nó chỉ có thể chứa được địa chỉ của biến kiểu float ) ; \n trong khi đó , Bien Nguyen có kiểu int , nghĩa là & Bien Nguyen \n chính là địa chỉ của 1 biến int . .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 105}}
{"text": "Lập trình căn bản \n II. 2.2 Nội dung của ô nhớ con trỏ chỉ tới \n Để truy cập đến nội dung của ô nhớ mà con trỏ chỉ tới , ta \n sử dụng cú pháp : \n * < Tên biến con trỏ > \n Với cách truy cập này thì * < Tên biến con trỏ > có thể coi \n là một biến có kiểu được mô tả trong phần khai báo biến con trỏ . \n Để ý rằng cách viết như trên chính là cách thức thao tác với các \n biến động . \n Thí dụ : Khai báo , gán địa chỉ cũng như lấy nội dung vùng \n nhớ của biến con trỏ : \n int x = 100 ; \n int * ptr ; \n ptr = & x ; \n int y = * ptr ; \n Lưu ý : Khi gán địa chỉ của một biến cho một biến con trỏ , \n mọi sự thay đổi trên nội dung ô nhớ con trỏ chỉ tới sẽ làm giá trị \n của biến thay đổi theo ( thực chất nội dung ô nhớ và biến chỉ là \n một ) . \n Thí dụ : Đoạn chương trình sau thấy rõ sự thay đổi này : \n # include < stdio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 106}}
{"text": "tf ( \" \\ nNoi dung cua o nho con tro pa \n tro toi = % d \" , * pa ) ; \n printf ( \" \\ nNoi dung cua o nho con tro pb \n tro toi = % d \" , * pb ) ; \n * pa = 20 ; / / Thay đổi giá trị của * pa \n * pb = 20 ; / / Thay đổi giá trị của * pb \n printf ( \" \\ nGia tri moi cua bien a = % d \\ n \n Gia tri moi cua bien b = % d \" , a , b ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 106}}
{"text": "Lập trình căn bản \n Kết quả thực hiện chương trình : \n II. 2.3 Cấp phát vùng nhớ để biến con trỏ quản lý địa chỉ \n Thực chất của con trỏ là chứa địa chỉ trong bộ nhớ của 1 \n biến khác ( thông thường gọi là 1 biến động ) . Đặc trưng của biến \n động chính là chúng được cấp phát 1 cách động trong quá trình \n thực hiện của chương trình . Ngôn ngữ C hỗ trợ một số hàm để \n cấp phát vùng nhớ cho các biến động này ; kết quả trả về của các \n hàm cấp phát này là địa chỉ bắt đầu ( con trỏ ) của vùng nhớ được \n cấp phát . Đó là các hàm malloc ( ) , calloc ( ) trong thư viện \n malloc . h . \n Cú pháp các hàm : \n - void * malloc ( size t size ) : Cấp phát vùng nhớ có kích \n thước là size . \n - void * calloc ( size t nitems , size t size ) : Cấp phát vùng \n nhớ có kích thước là nitems * size . \n Thí dụ : Giả sử ta có khai báo : \n int a , * pa , * pb ; \n pa = ( int * ) malloc ( sizeof ( int ) ) ; / * Cấp phát vùng \n nhớ có kích thước bằng với kích thước của một số nguyên * / \n pb = ( int * ) calloc ( 10 , sizeof ( int ) ) ; / * Cấp phát vùng \n nhớ có thể chứa được 10 số nguyên * / \n Lúc này hình ảnh trong bộ nhớ như sau : \n 0 1 2 3 4 5 6 7 8 9\n\npa 2 byte pb 2 byte", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 107}}
{"text": "0 , sizeof ( int ) ) ; / * Cấp phát vùng \n nhớ có thể chứa được 10 số nguyên * / \n Lúc này hình ảnh trong bộ nhớ như sau : \n 0 1 2 3 4 5 6 7 8 9\n\npa 2 byte pb 2 byte", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 107}}
{"text": "Lập trình căn bản \n Lưu ý : Khi sử dụng hàm malloc ( ) hay calloc ( ) , ta phải ép \n kiểu vì nguyên mẫu ( prototype ) của các hàm này trả về con trỏ \n kiểu void . \n II. 3.4 Cấp phát lại vùng nhớ cho biến con trỏ \n Trong quá trình thao tác trên biến con trỏ , nếu ta cần cấp \n phát thêm vùng nhớ có kích thước lớn hơn vùng nhớ đã cấp phát , \n ta sử dụng hàm realloc ( ) . \n Cú pháp : void * realloc ( void * block , size t size ) \n Ý nghĩa : \n - Cấp phát lại 1 vùng nhớ cho con trỏ block quản lý , vùng \n nhớ này có kích thước mới là size ; khi cấp phát lại thì nội dung \n vùng nhớ trước đó vẫn tồn tại . \n - Kết quả trả về của hàm là địa chỉ đầu tiên của vùng nhớ \n mới . Địa chỉ này có thể khác với địa chỉ được chỉ ra khi cấp phát \n ban đầu . \n Thí dụ : Trong thí dụ trên ta có thể cấp phát lại vùng nhớ \n do con trỏ pa quản lý như sau : \n int a , * pa ; \n pa = ( int * ) malloc ( sizeof ( int ) ) ; / * Cấp phát vùng \n nhớ có kích thước 2 byte * / \n pa = realloc ( pa , 6 ) ; / * Cấp phát lại vùng nhớ có \n kích thước 6 byte * / \n II. 3.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 108}}
{"text": "nhớ có \n kích thước 6 byte * / \n II. 3.5 Giải phóng vùng nhớ cho biến con trỏ \n Một vùng nhớ đã cấp phát được quản lý bởi 1 biến con trỏ , \n khi không còn sử dụng nữa , ta sẽ thu hồi lại vùng nhớ này nhờ \n hàm free ( ) . \n Cú pháp : void free ( void * block ) \n Ý nghĩa : Giải phóng vùng nhớ được quản lý bởi con trỏ \n block . \n Thí dụ : Ở thí dụ trên , sau khi thực hiện xong , ta giải phóng \n vùng nhớ cho 2 biến con trỏ pa & pb : \n free ( pa ) ; free ( pb ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 108}}
{"text": "Lập trình căn bản \n II. 3.6 Một số phép toán trên con trỏ \n a . Phép gán con trỏ : Hai con trỏ cùng kiểu có thể gán cho \n nhau . \n Thí dụ : int a , * p , * a ; float * f ; \n a = 5 ; p = & a ; q = p ; / * đúng * / \n f = p ; / * sai do khác kiểu * / \n Ta cũng có thể ép kiểu con trỏ theo cú pháp : \n ( < Kiểu kết quả > * ) < Tên con trỏ > \n Chẳng hạn , thí dụ trên được viết lại : \n int a , * p , * a ; float * f ; \n a = 5 ; p = & a ; q = p ; / * đúng * / \n f = ( float * ) p ; / / Đúng nhờ ép kiểu \n b . Cộng , trừ con trỏ với một số nguyên : Ta có thể cộng \n ( + ) , trừ ( - ) 1 con trỏ với 1 số nguyên N nào đó ; kết quả trả về là 1 \n con trỏ . Con trỏ này chỉ đến vùng nhớ cách vùng nhớ của con trỏ \n hiện tại N phần tử . \n Thí dụ : Cho đoạn chương trình sau : \n int * pa ; \n pa = ( int * ) malloc ( 20 ) ; / * Cấp phát vùng nhớ 20 \n byte = 10 số nguyên * / \n int * pb , * pc ; \n pb = pa + 7 ; \n pc = pb - 3 ; \n Lúc này hình ảnh của pa , pb , pc như sau : \n 0 1 2 3 4 5 6 7 8 9\n\npa pc pb \n c . Con trỏ NULL : là con trỏ không chứa địa chỉ nào cả . Ta \n có thể gán giá trị NULL cho 1 con trỏ có kiểu bất kỳ . \n d . Lưu ý : \n - Ta không thể cộng 2 con trỏ với nhau .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 109}}
{"text": "trỏ NULL : là con trỏ không chứa địa chỉ nào cả . Ta \n có thể gán giá trị NULL cho 1 con trỏ có kiểu bất kỳ . \n d . Lưu ý : \n - Ta không thể cộng 2 con trỏ với nhau . \n - Phép trừ 2 con trỏ cùng kiểu sẽ trả về 1 giá trị nguyên \n ( int ) . Đây chính là khoảng cách ( số phần tử ) giữa 2 con trỏ đó . \n Chẳng hạn , trong ví dụ trên pc - pa = 4 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 109}}
{"text": "Lập trình căn bản \n III. CON TRỎ VÀ MẢNG \n Giữa mảng và con trỏ có một sự liên hệ rất chặt chẽ . Trong C , \n thực chất tên mảng chính là con trỏ chứa địa chỉ của phần tử đầu \n tiên trong mảng đó . Do đó , những phần tử của mảng có thể được \n xác định bằng chỉ số trong mảng , bên cạnh đó chúng cũng có thể \n được xác lập qua biến con trỏ . \n III. 1 Con trỏ và mảng 1 chiều \n III. 1.1 Truy cập các phần tử mảng theo dạng con trỏ \n Ta có các quy tắc sau : \n & < Tên mảng > [ 0 ] tương đương với < Tên mảng > \n & < Tên mảng > [ < Vị trí > ] tương đương với < Tên mảng > + < Vị trí > \n < Tên mảng > [ < Vị trí > ] tương đương với * ( < Tên mảng > + < Vị trí > ) \n Thí dụ : Cho 1 mảng 1 chiều các số nguyên a có 5 phần tử , \n truy cập các phần tử theo kiểu mảng và theo kiểu con trỏ . \n # include < stdio . h > \n # include < conio .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 110}}
{"text": "d \" , & a [ i ] ) ; \n } \n } \n / / Nhập mảng theo dạng con trỏ \n void NhapContro ( int a [ ] , int N ) { \n int i ; \n for ( i = 0 ; i < N ; i + + ) \n { \n printf ( \" Phan tu thu % d : \" , i ) ; \n scanf ( \" % d \" , a + i ) ; \n } \n } \n main ( ) \n { \n int a [ 20 ] , N , i ; \n printf ( \" So phan tu N = \" ) ; scanf ( \" % d \" , & N ) ; \n NhapMang ( a , N ) ; / / NhapContro ( a , N )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 110}}
{"text": "Lập trình căn bản \n printf ( \" Truy cap theo kieu mang : \" ) ; \n for ( i = 0 ; i < N ; i + + ) \n printf ( \" % d \" , a [ i ] ) ; \n printf ( \" \\ nTruy cap theo kieu con tro : \" ) ; \n for ( i = 0 ; i < N ; i + + ) \n printf ( \" % d \" , * ( a + i ) ) ; \n getch ( ) ; \n } \n Kết quả thực thi của chương trình : \n III. 1.2 Truy xuất từng phần tử đang được quản lý bởi con trỏ \n theo dạng mảng \n < Tên biến > [ < Vị trí > ] tương đương với * ( < Tên biến > + < Vị trí > ) \n & < Tên biến > [ < Vị trí > ] tương đương với ( < Tên biến > + < Vị trí > ) \n Trong đó < Tên biến > là biến con trỏ , < Vị trí > là 1 biểu \n thức số nguyên . \n Thí dụ : Giả sử có khai báo : \n # include < stdio . h > \n # include < malloc . h > \n # include < conio . h > \n main ( ) { \n int * a ; \n int i ; \n a = ( int * ) malloc ( sizeof ( int ) * 10 ) ; \n for ( i = 0 ; i < 10 ; i + + ) \n a [ i ] = 2 * i ; \n printf ( \" Truy cap theo kieu mang : \" ) ; \n for ( i = 0 ; i < 10 ; i + + ) \n printf ( \" % d \" , a [ i ] ) ; \n printf ( \" \\ nTruy cap theo kieu con tro : \" ) ; \n for ( i = 0 ; i < 10 ; i + + ) \n printf ( \" % d \" , * ( a + i ) ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 111}}
{"text": "uy cap theo kieu con tro : \" ) ; \n for ( i = 0 ; i < 10 ; i + + ) \n printf ( \" % d \" , * ( a + i ) ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 111}}
{"text": "Lập trình căn bản \n Kết quả chương trình : \n Với khai báo ở trên , hình ảnh của con trỏ a trong bộ nhớ : \n 0 1 2 3 4 5 6 7 8 9\n\n| 0 | 2 | 4 | 6 | 8 | 10 | 12 | 14 | 16 | 18 |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n\n\na 2 byte \n III. 1.3 Con trỏ chỉ đến phần tử mảng \n Giả sử con trỏ ptr chỉ đến phần tử a [ i ] nào đó của mảng a \n thì : \n ptr + j chỉ đến phần tử thứ j sau a [ i ] , tức a [ i + j ] \n ptr - j chỉ đến phần tử đứng trước a [ i ] , tức a [ i - j ] \n Thí dụ : Giả sử có 1 mảng mang int , cho con trỏ contro int \n chỉ đến phần tử thứ 5 trong mảng . In ra các phần tử của \n contro int & mang int . \n # include < stdio . h > \n # include < conio . h > \n # include < malloc .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 112}}
{"text": "ntf ( \" \\ nNoi dung cua contro int ban dau = \" ) ; \n for ( i = 0 ; i < 5 ; i + + ) \n printf ( \" % d \" , contro int [ i ] ) ; \n for ( i = 0 ; i < 5 ; i + + ) \n contro int [ i ] + + ; \n printf ( \" \\ n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \" ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 112}}
{"text": "Lập trình căn bản \n printf ( \" \\ nNoi dung cua mang int sau khi tang 1 = \" ) ; \n for ( i = 0 ; i < = 9 ; i + + ) \n printf ( \" % d \" , mang int [ i ] ) ; \n printf ( \" \\ nNoi dung cua contro int \n sau khi tang 1 = \" ) ; \n for ( i = 0 ; i < 5 ; i + + ) \n printf ( \" % d \" , contro int [ i ] ) ; \n if ( contro int ! = NULL ) \n free ( contro int ) ; \n getch ( ) ; \n } \n Kết quả chương trình \n III. 2 Con trỏ và mảng nhiều chiều \n Giả sử ta có mảng 2 chiều và biến con trỏ như sau : \n int a [ n ] [ m ] ; \n int * contro int ; \n Thực hiện phép gán contro int = a ; \n Khi đó phần tử a [ 0 ] [ 0 ] được quản lý bởi contro int ; \n a [ 0 ] [ 1 ] được quản lý bởi contro int + 1 ; \n a [ 0 ] [ 2 ] được quản lý bởi contro int + 2 ; \n ... \n a [ 1 ] [ 0 ] được quản lý bởicontro int + m ; \n a [ 1 ] [ 1 ] được quản lý bởi contro int + m + 1 ; \n ... \n a [ n ] [ m ] được quản lý bởi contro int + n * m ; \n Tương tự như thế đối với mảng nhiều hơn 2 chiều .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 113}}
{"text": "Lập trình căn bản \n Thí dụ : Sự tương đương giữa mảng 2 chiều và con trỏ . \n # include < stdio . h > \n # include < conio . h > \n # include < malloc . h > \n main ( ) \n { \n int i , j ; \n int mang int [ 4 ] [ 5 ] = { 1,2,3,4,5,6,7,8,9,10,11 , \n 12,13,14,15,16,17,18,19,20 } ; \n int * contro int ; \n contro int = ( int * ) mang int ; \n printf ( \" \\ nNoi dung cua mang int ban dau = \" ) ; \n for ( i = 0 ; i < 4 ; i + + ) \n { \n printf ( \" \\ n \" ) ; \n for ( j = 0 ; j < 5 ; j + + ) \n printf ( \" % d \\ t \" , mang int [ i ] [ j ] ) ; \n } \n printf ( \" \\ n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \" ) ; \n printf ( \" \\ nNoi dung cua contro int ban dau \\ n \" ) ; \n for ( i = 0 ; i < 20 ; i + + ) \n printf ( \" % d \" , contro int [ i ] ) ; \n for ( i = 0 ; i < 20 ; i + + ) \n contro int [ i ] + + ; \n printf ( \" \\ n - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \" ) ; \n printf ( \" \\ nNoi dung cua mang int sau khi tang 1 = \" ) ; \n for ( i = 0 ; i < 4 ; i + + ) \n { \n printf ( \" \\ n \" ) ; \n for ( j = 0 ; j < 5 ; j + + ) \n printf ( \" % d \\ t \" , mang int [ i ] [ j ] ) ; \n } \n printf ( \" \\ nNoi dung cua contro int \n sau khi tang 1 = \\ n \" ) ; \n for ( i = 0 ; i", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 114}}
{"text": "{ \n printf ( \" \\ n \" ) ; \n for ( j = 0 ; j < 5 ; j + + ) \n printf ( \" % d \\ t \" , mang int [ i ] [ j ] ) ; \n } \n printf ( \" \\ nNoi dung cua contro int \n sau khi tang 1 = \\ n \" ) ; \n for ( i = 0 ; i < 20 ; i + + ) \n printf ( \" % d \" , contro int [ i ] ) ; \n if ( contro int ! = NULL ) \n free ( contro int ) ; \n getch ( ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 114}}
{"text": "Lập trình căn bản \n } \n Kết quả thực hiện chương trình như sau : \n IV. CON TRỎ LÀ THAM SỐ HÌNH THỨC CỦA HÀM \n Khi tham số hình thức của hàm là một con trỏ thì theo nguyên tắc \n gọi hàm ta dùng tham số thực tế là 1 con trỏ có kiểu giống với \n kiểu của tham số hình thức . Nếu lúc thực thi hàm ta có sự thay \n đổi trên nội dung vùng nhớ được chỉ bởi con trỏ tham số hình \n thức thì lúc đó nội dung vùng nhớ được chỉ bởi tham số thực tế \n cũng sẽ bị thay đổi theo . \n Thí dụ : Xét hàm hoán vị được viết như sau : \n # include < stdio . h > \n # include < conio . h > \n void HoanVi ( int * a , int * b ) { \n int c = * a ; \n * a = * b ; \n * b = c ; \n } \n main ( ) { \n int m = 20 , n = 30 ; \n printf ( \" Truoc khi goi ham m = % d , \n n = % d \\ n \" , m , n ) ; \n HoanVi ( & m , & n ) ; \n printf ( \" Sau khi goi ham m = % d , \n n = % d \" , m , n ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 115}}
{"text": "Lập trình căn bản \n Kết quả thực thi chương trình : \n Giải thích : \n Với việc khi tham số hình thức là 1 con trỏ có thể làm thay \n đổi giá trị của vùng dữ liệu của con trỏ tham số thực tế nên người \n ta có thể sử dụng cách thức truyền tham số là con trỏ để có thể \n nhận kết quả trả về là vùng dữ liệu của con trỏ tham số thực tế . \n Thí dụ : Viết 1 hàm tính n ! nhưng sử dụng tham số hình \n thức là 1 con trỏ để có thể nhận được kết quả trả về sau khi thực \n thi hàm :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 116}}
{"text": "Lập trình căn bản \n void giaithua ( int n , long * K ) { \n int i ; \n ( * K ) = 1L ; \n for ( i = 1 ; i < = n ; i + + ) \n ( * K ) = ( * K ) * i ; \n } \n main ( ) { \n int n ; \n long KQ ; \n printf ( \" Nhap so n = \" ) ; scanf ( \" % d \" , & n ) ; \n giaithua ( n , & KQ ) ; \n printf ( \" \\ n % d ! = % ld \" , n , KQ ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 117}}
{"text": "Lập trình căn bản \n Chương 8 \n CHUỖI KÝ TỰ \n Các vấn đề được trình bày trong chương này : \n  Khái niệm về chuỗi ký tự . \n  Một số hàm xử lý chuỗi và áp dụng của chúng . \n I. KHÁI NIỆM \n Chuỗi ký tự là một dãy gồm các ký tự hoặc một mảng các \n ký tự được kết thúc bằng ký tự ‘ \\ 0 ’ ( còn được gọi là ký tự NULL \n trong bảng mã ASCII ) . \n Các hằng chuỗi ký tự được đặt trong cặp dấu nháy kép “ ” . \n II. KHAI BÁO \n Ngôn ngữ C không hỗ trợ chuỗi ký tự như là 1 kiểu riêng . Thực \n chất chuỗi ký tự trong C được coi như là 1 mảng gồm các phần tử \n là 1 ký tự ( kiểu char ) với ký tự cuối cùng là ký tự có mã ASCII là \n 0 ( ‘ \\ 0 ’ ) . Vì thế , việc khai báo chuỗi ký tự trong C chính là khai \n báo 1 mảng ký tự ( hoặc có thể là 1 con trỏ chỉ đến vùng nhớ 1 ký \n tự ) . \n II. 1 Khai báo theo mảng \n Cú pháp : char < Biến > [ Chiều dài tối đa ] \n Thí dụ : Trong chương trình , ta có khai báo : \n char Ten [ 12 ] ; \n Đây là khai báo của 1 biến chuỗi Ten có chiều dài \n tối đa 12 ký tự . \n Ghi chú : \n - Chiều dài tối đa không nên khai báo thừa để tránh lãng \n phí bộ nhớ , nhưng cũng không nên khai báo thiếu .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 118}}
{"text": "Chiều dài tối đa không nên khai báo thừa để tránh lãng \n phí bộ nhớ , nhưng cũng không nên khai báo thiếu . \n - Với việc khai báo 1 mảng ký tự như trên , ký tự ‘ \\ 0 ’ \n không được tự động thêm vào cuối chuỗi .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 118}}
{"text": "Lập trình căn bản \n II. 2 Khai báo theo con trỏ \n Cú pháp : char * < Biến > \n Thí dụ : Trong chương trình , ta có khai báo : \n char * Ten ; \n Trong khai báo này , bộ nhớ sẽ dành 2 byte để lưu \n trữ địa chỉ của biến con trỏ Ten đang chỉ đến , chưa cung cấp nơi \n để lưu trữ dữ liệu . Muốn có chỗ để lưu trữ dữ liệu , ta phải gọi đến \n hàm malloc ( ) hoặc calloc ( ) có trong “ malloc . h ” , sau đó mới gán \n dữ liệu cho biến . \n II. 3 Vừa khai báo vừa gán giá trị \n Cú pháp : char < Biến > [ ] = < ” Hằng chuỗi ” > \n Thí dụ : \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n char Chuoi [ ] = \" Mau nang hay la mau mat em ” ; \n printf ( \" Vua khai bao vua gan trị : % s ” , \n Chuoi ) ; \n getch ( ) ; \n } \n Ghi chú : Chuỗi được khai báo là một mảng các ký tự nên \n các thao tác trên mảng có thể áp dụng đối với chuỗi ký tự . \n III. CÁC THAO TÁC TRÊN CHUỖI KÝ TỰ \n III. 1 . Nhập xuất chuỗi \n III. 1.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 119}}
{"text": "( ) \n Cú pháp : gets ( < Biến chuỗi > ) \n Thí dụ : char Ten [ 20 ] ; \n gets ( Ten ) ; \n Ta cũng có thể sử dụng hàm scanf ( ) để nhập dữ liệu cho \n biến chuỗi , tuy nhiên lúc này ta chỉ có thể nhập được một chuỗi \n không có dấu khoảng trắng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 119}}
{"text": "Lập trình căn bản \n Khi nhập chuỗi bằng hàm gets , ký tự ‘ \\ 0 ’ được tự động \n thêm vào cuối chuỗi . \n III. 1.2 Xuất chuỗi lên màn hình \n Để xuất một chuỗi ( biểu thức chuỗi ) lên màn hình , ta sử \n dụng hàm puts ( ) . \n Cú pháp : puts ( < Biểu thức chuỗi > ) \n Thí dụ : Nhập vào một chuỗi và hiển thị trên màn hình chuỗi \n vừa nhập . \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n main ( ) { \n char Ten [ 12 ] ; \n printf ( \" Nhap chuoi : \" ) ; gets ( Ten ) ; \n printf ( \" Chuoi vua nhap : \" ) ; puts ( Ten ) ; \n getch ( ) ; \n } \n Ngoài ra , ta có thể sử dụng hàm printf ( ) , cputs ( ) ( trong \n conio . h ) để hiển thị chuỗi lên màn hình . \n III. 2 Một số hàm xử lý chuỗi ( trong string . h ) \n III. 2.1 Cộng chuỗi - Hàm strcat ( ) \n Cú pháp : char * strcat ( char * des , const char * source ) \n Hàm này có tác dụng ghép chuỗi nguồn vào chuỗi đích . \n Thí dụ : Nhập vào họ lót và tên của một người , sau đó in cả \n họ và tên của họ lên màn hình . \n # include < stdio . h > \n # include < string .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 120}}
{"text": "tdio . h > \n # include < string . h > \n main ( ) { \n char HoLot [ 30 ] , Ten [ 12 ] ; \n printf ( \" Nhap Ho Lot : \" ) ; gets ( HoLot ) ; \n printf ( \" Nhap Ten : \" ) ; gets ( Ten ) ; \n strcat ( HoLot , Ten ) ; / / Ghep Ten vao HoLot \n printf ( \" Ho ten la : \" ) ; puts ( HoLot ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 120}}
{"text": "Lập trình căn bản \n III. 2.2 Xác định độ dài chuỗi - Hàm strlen ( ) \n Cú pháp : int strlen ( const char * s ) \n Thí dụ : Sử dụng hàm strlen xác định độ dài một chuỗi \n nhập từ bàn phím . \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n main ( ) \n { \n char Chuoi [ 255 ] ; \n int Dodai ; \n printf ( \" Nhap chuoi : \" ) ; gets ( Chuoi ) ; \n Dodai = strlen ( Chuoi ) \n printf ( \" Chuoi vua nhap : \" ) ; puts ( Chuoi ) ; \n printf ( “ Co do dai % d ” , Dodai ) ; \n getch ( ) ; \n } \n III. 2.3 Đổi một ký tự thường thành ký tự hoa và ngược lại \n Hàm toupper ( ) ( trong ctype . h ) cho phép trả về ký tự hoa \n của 1 ký tự đầu vào là tham số của hàm . Ngược lại , hàm \n tolower ( ) trả về ký tự thường của ký tự đầu vào là tham số của \n hàm . \n Cú pháp : char toupper ( char c ) \n char tolower ( chart c ) \n III. 2.4 Đổi chuỗi chữ thường thành chuỗi chữ hoa , hàm strupr ( ) \n Hàm struppr ( ) được dùng để chuyển đổi chuỗi chữ thường \n thành chuỗi chữ hoa , kết quả trả về của hàm là một con trỏ chỉ \n đến địa chỉ chuỗi được chuyển đổi . \n Cú pháp : char * strupr ( char * s ) \n Thí dụ : Viết chương trình nhập vào một chuỗi ký tự từ bàn \n phím .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 121}}
{"text": "àm là một con trỏ chỉ \n đến địa chỉ chuỗi được chuyển đổi . \n Cú pháp : char * strupr ( char * s ) \n Thí dụ : Viết chương trình nhập vào một chuỗi ký tự từ bàn \n phím . Sau đó sử dụng hàm strupr ( ) để chuyển đổi chúng thành \n chuỗi chữ hoa . \n # include < conio . h > \n # include < stdio . h > \n # include < string . h >", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 121}}
{"text": "Lập trình căn bản \n main ( ) { \n char Chuoi [ 255 ] , * s ; \n printf ( \" Nhap chuoi : \" ) ; gets ( Chuoi ) ; \n s = strupr ( Chuoi ) ; \n printf ( “ Chuoi chu hoa : ” ) ; puts ( s ) ; \n getch ( ) ; \n } \n III. 2.5 Đổi chuỗi chữ hoa thành chuỗi chữ thường , hàm strlwr ( ) \n Muốn chuyển đổi chuỗi chữ hoa thành chuỗi toàn chữ \n thường , ta sử dụng hàm strlwr ( ) , các tham số của hàm tương tự \n như hàm strupr ( ) \n Cú pháp : char * strlwr ( char * s ) \n III. 2.6 Sao chép chuỗi , hàm strcpy ( ) \n Hàm này được dùng để sao chép toàn bộ nội dung của \n chuỗi nguồn vào chuỗi đích . \n Cú pháp : char * strcpy ( char * Des , const char * Source ) \n Thí dụ : Viết chương trình cho phép chép toàn bộ chuỗi \n nguồn vào chuỗi đích . \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n main ( ) { \n char Chuoi [ 255 ] , s [ 255 ] ; \n printf ( \" Nhap chuoi : \" ) ; gets ( Chuoi ) ; \n strcpy ( s , Chuoi ) ; \n printf ( “ Chuoi dich : ” ) ; puts ( s ) ; \n getch ( ) ; \n } \n III. 2.7 Sao chép một phần chuỗi , hàm strncpy ( ) \n Hàm này cho phép chép n ký tự đầu tiên của chuỗi nguồn \n sang chuỗi đích . \n Cú pháp : \n char * strncpy ( char * Des , const char * Source , size t n )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 122}}
{"text": "chép một phần chuỗi , hàm strncpy ( ) \n Hàm này cho phép chép n ký tự đầu tiên của chuỗi nguồn \n sang chuỗi đích . \n Cú pháp : \n char * strncpy ( char * Des , const char * Source , size t n )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 122}}
{"text": "Lập trình căn bản \n Để ý rằng khi sao chép n ký tự đầu tiên của chuỗi nguồn \n vào chuỗi đích , ký tự ‘ \\ 0 ’ không được tự động thêm vào chuỗi \n đích . \n III. 2.8 Trích một phần chuỗi , hàm strchr ( ) \n Để trích một chuỗi con của một chuỗi ký tự bắt đầu từ một \n ký tự được chỉ định trong chuỗi cho đến hết chuỗi , ta sử dụng \n hàm strchr ( ) . \n Cú pháp : char * strchr ( const char * str , int c ) \n Ghi chú : \n - Nếu ký tự đã chỉ định không có trong chuỗi , kết quả trả \n về là NULL. \n - Kết quả trả về của hàm là một con trỏ , con trỏ này chỉ \n đến ký tự c được tìm thấy đầu tiên trong chuỗi str . \n III. 2.9 Tìm kiếm nội dung chuỗi , hàm strstr ( ) \n Hàm strstr ( ) được sử dụng để tìm kiếm sự xuất hiện đầu \n tiên của chuỗi s2 trong chuỗi s1 . \n Cú pháp : char * strstr ( const char * s1 , const char * s2 ) \n Kết quả trả về của hàm là một con trỏ chỉ đến phần tử đầu \n tiên của chuỗi s1 có chứa chuỗi s2 hoặc giá trị NULL nếu chuỗi \n s2 không có trong chuỗi s1 . \n Thí dụ : Viết chương trình sử dụng hàm strstr ( ) để lấy ra \n một phần của chuỗi gốc bắt đầu từ chuỗi “ hoc ” . \n # include < conio . h > \n # include < stdio . h > \n # include < string .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 123}}
{"text": "ử dụng hàm strstr ( ) để lấy ra \n một phần của chuỗi gốc bắt đầu từ chuỗi “ hoc ” . \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n main ( ) { \n char Chuoi [ 255 ] , * s ; \n printf ( \" Nhap chuoi : \" ) ; gets ( Chuoi ) ; \n s = strstr ( Chuoi , ” hoc ” ) ; \n printf ( “ Chuoi trich ra : ” ) ; puts ( s ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 123}}
{"text": "Lập trình căn bản \n III. 2.10 So sánh chuỗi , hàm strcmp ( ) \n Để so sánh hai chuỗi theo từng ký tự trong bảng mã Ascii , \n ta có thể sử dụng hàm strcmp ( ) . \n Cú pháp : int strcmp ( const char * s1 , const char * s2 ) \n Hai chuỗi s1 và s2 được so sánh với nhau , kết quả trả về là \n một số nguyên ( số này có được bằng cách lấy ký tự của s1 trừ ký \n tự của s2 tại vị trí đầu tiên xảy ra sự khác nhau hoặc là 0 nếu 1 \n chuỗi giống nhau hoàn toàn ) . \n - Nếu kết quả là số âm , chuỗi s1 nhỏ hơn chuỗi s2 . \n - Nếu kết quả là 0 , hai chuỗi bằng nhau . \n - Nếu kết quả là số dương , chuỗi s1 lớn hơn chuỗi s2 . \n III. 2.11 So sánh chuỗi , hàm stricmp ( ) \n Hàm này thực hiện việc so sánh trong n ký tự đầu tiên của \n 2 chuỗi s1 và s2 , giữa chữ thường và chữ hoa không phân biệt . \n Cú pháp : int stricmp ( const char * s1 , const char * s2 ) \n Kết quả trả về tương tự như kết quả trả về của hàm \n strcmp ( ) . \n III. 2.12 Khởi tạo chuỗi , hàm memset ( ) \n Hàm này được sử dụng để đặt n ký tự đầu tiên của chuỗi là \n ký tự c . \n Cú pháp : memset ( char * Des , int c , size t n ) \n III. 2.13 Đổi từ chuỗi ra số , hàm atoi ( ) , atof ( ) , atol ( ) ( trong \n stdlib .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 124}}
{"text": "của chuỗi là \n ký tự c . \n Cú pháp : memset ( char * Des , int c , size t n ) \n III. 2.13 Đổi từ chuỗi ra số , hàm atoi ( ) , atof ( ) , atol ( ) ( trong \n stdlib . h ) \n Để chuyển đổi chuỗi ra số , ta sử dụng các hàm trên . \n Cú pháp : int atoi ( const char * s ) : chuyển chuỗi \n thành số nguyên \n long atol ( const char * s ) : chuyển chuỗi \n thành số nguyên dài \n float atof ( const char * s ) : chuyển chuỗi \n thành số thực", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 124}}
{"text": "Lập trình căn bản \n Nếu chuyển đổi không thành công , kết quả trả về của các \n hàm là 0 . \n Ngoài ra , thư viện string . h còn hỗ trợ các hàm xử lý chuỗi \n khác , ta có thể đọc thêm trong phần trợ giúp . \n IV. BÀI TẬP \n 1 . Viết chương trình nhập một chuỗi ký tự từ bàn phím , xuất ra \n màn hình mã Ascii của từng ký tự có trong chuỗi . \n 2 . Viết chương trình nhập một chuỗi ký tự từ bàn phím , xuất ra \n màn hình chuỗi đảo ngược của chuỗi đó . Thí dụ đảo của “ abcd \n egh ” là “ hge dcba ” . \n 3 . Viết chương trình nhập một chuỗi ký tự và kiểm tra xem chuỗi \n đó có đối xứng không . \n Thí dụ : Chuỗi ABCDEDCBA là chuỗi đối xứng . \n 4 . Nhập vào một chuỗi bất kỳ , hãy đếm số lần xuất hiện của mỗi \n ký tự có trong chuỗi . \n 5 . Viết chương trình nhập vào một chuỗi . \n - Hiển thị lên màn hình từ bên trái nhất và phần còn lại của \n chuỗi . Thí dụ : “ Nguyen Van Minh ” in ra thành : \n Nguyen \n Van Minh \n - Hiển thị lên màn hình từ bên phải nhất và phần còn lại \n của chuỗi . Thí dụ : “ Nguyen Van Minh ” in ra thành : \n Minh \n Nguyen Van \n 6 . Viết chương trình nhập vào một chuỗi rồi xuất chuỗi đó ra màn \n hình dưới dạng mỗi từ một dòng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 125}}
{"text": "Minh ” in ra thành : \n Minh \n Nguyen Van \n 6 . Viết chương trình nhập vào một chuỗi rồi xuất chuỗi đó ra màn \n hình dưới dạng mỗi từ một dòng . \n Thí dụ : “ Nguyễn Văn Minh ” \n In ra : \n Nguyen \n Van \n Minh", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 125}}
{"text": "Lập trình căn bản \n 7 . Viết chương trình nhập vào một chuỗi , in ra chuỗi đảo ngược \n của nó theo từng từ . \n Thí dụ : chuỗi “ Nguyen Van Minh ” đảo thành “ Minh Van \n Nguyen ” . \n 8 . Viết chương trình nhập vào họ và tên của một người , cắt bỏ \n các khoảng trống không cần thiết ( nếu có ) , tách tên ra khỏi họ và \n tên , in tên lên màn hình . Chú ý đến trường hợp cả họ và tên chỉ \n có một từ . \n 9 . Viết chương trình nhập vào họ và tên của một người , cắt bỏ \n các khoảng trắng bên phải , trái và các khoảng trắng không có \n nghĩa trong chuỗi . In ra màn hình toàn bộ họ tên người đó dưới \n dạng chữ hoa , chữ thường . \n 10 . Viết chương trình nhập vào một danh sách họ và tên của n \n người theo kiểu chữ thường , đổi các chữ cái đầu của họ , tên và \n chữ lót của mỗi người thành chữ hoa . In kết quả lên màn hình . \n 11 . Viết chương trình nhập vào một danh sách họ và tên của n \n người , tách tên từng người ra khỏi họ và tên rồi sắp xếp danh \n sách tên theo thứ tự từ điển . In danh sách họ và tên sau khi đã sắp \n xếp .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 126}}
{"text": "Lập trình căn bản \n Chương 9 \n KIỂU CẤU TRÚC - STRUCT \n Chương này trình bày các vấn đề sau : \n  Khái niệm về kiểu cấu trúc . \n  Cách sử dụng kiểu cấu trúc . \n  Con trỏ cấu trúc . \n I. KIỂU CẤU TRÚC \n I. 1 Khái niệm \n Kiểu cấu trúc ( Structure ) là kiểu dữ liệu bao gồm nhiều thành \n phần có kiểu khác nhau , mỗi thành phần được gọi là một trường \n ( field ) . \n Sự khác biệt giữa kiểu cấu trúc và kiểu mảng là : các phần tử của \n mảng là cùng kiểu còn các phần tử của kiểu cấu trúc có thể có \n kiểu khác nhau . \n Hình ảnh của kiểu cấu trúc được minh họa : \n 1 2 3 4 5 6 7\n\nĐây là cấu trúc có 7 trường \n Còn kiểu mảng có dạng : \n 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14\n\nĐây là mảng có 15 phần tử", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 127}}
{"text": "Lập trình căn bản \n I. 2 Định nghĩa kiểu cấu trúc \n Cách 1 : \n struct < Tên cấu trúc > \n { \n < Kiểu > < Trường 1 > ; \n < Kiểu > < Trường 2 > ; \n … … . . \n < Kiểu > < Trường n > ; \n } ; \n Cách 2 : Sử dụng từ khóa typedef để định nghĩa kiểu : \n typedef struct \n { \n < Kiểu > < Trường 1 > ; \n < Kiểu > < Trường 2 > ; \n … … . . \n < Kiểu > < Trường n > ; \n } < Tên cấu trúc > ; \n Trong đó : \n - < Tên cấu trúc > : là một tên được đặt theo quy tắc đặt tên \n của danh biểu ; tên này mang ý nghĩa sẽ là tên kiểu cấu trúc . \n - < Kiểu > < Trường i > ( i = 1 . . n ) : mỗi trường trong cấu trúc \n có dữ liệu thuộc kiểu gì ( tên của trường phải là một tên được đặt \n theo quy tắc đặt tên của danh biểu ) . \n Thí dụ 1 : Để quản lý ngày , tháng , năm của một ngày \n trong năm ta có thể khai báo kiểu cấu trúc gồm 3 thông tin : ngày , \n tháng , năm . \n struct NgayThang { typedef struct { \n unsigned char Ngay ; unsigned char Ngay ; \n unsigned char Thang ; unsigned char Thang ; \n unsigned int Nam ; \n unsigned int Nam ; \n } NgayThang ; \n } ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 128}}
{"text": "Lập trình căn bản \n Thí dụ 2 : Mỗi sinh viên cần được quản lý bởi các thông \n tin : mã số sinh viên , họ tên , ngày tháng năm sinh , giới tính , địa \n chỉ thường trú . Lúc này ta có thể khai báo một struct gồm các \n thông tin trên . \n struct SinhVien { typedef struct { \n char MSSV [ 10 ] ; char MSSV [ 10 ] ; \n char HoTen [ 40 ] ; char HoTen [ 40 ] ; \n struct NgayThang NgaySinh ; NgayThang NgaySinh ; \n int Phai ; int Phai ; \n char DiaChi [ 40 ] ; char DiaChi [ 40 ] ; \n } SinhVien ; \n } ; \n I. 3 Khai báo biến cấu trúc \n Việc khai báo biến cấu trúc cũng tương tự như khai báo biến \n thuộc kiểu dữ liệu chuẩn . \n Cú pháp : \n - Đối với cấu trúc được định nghĩa theo cách 1 : \n struct < Tên cấu trúc > < Biến 1 > [ , < Biến 2 > … ] ; \n - Đối với các cấu trúc được định nghĩa theo cách 2 : \n < Tên cấu trúc > < Biến 1 > [ , < Biến 2 > … ] ; \n Thí dụ : Khai báo biến NgaySinh có kiểu cấu trúc \n NgayThang ; biến SV có kiểu cấu trúc SinhVien . \n struct NgayThang NgaySinh ; NgayThang NgaySinh ; \n struct SinhVien SV ; SinhVien SV ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 129}}
{"text": "Lập trình căn bản \n II. CÁC THAO TÁC TRÊN BIẾN KIỂU CẤU TRÚC \n II. 1 Truy xuất đến từng trường của biến cấu trúc \n Cú pháp : < Biến cấu trúc > . < Tên trường > \n Khi sử dụng cách truy xuất theo kiểu này , các thao tác trên \n < Biến cấu trúc > . < Tên trường > giống như các thao tác trên các \n biến của kiểu dữ liệu của < Tên trường > . \n Thí dụ 1 : Viết chương trình cho phép đọc dữ liệu từ bàn \n phím cho biến cấu trúc SinhVien và hiển thị biến cấu trúc đó lên \n màn hình : \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n typedef struct { \n unsigned char Ngay ; \n unsigned char Thang ; \n unsigned int Nam ; \n } NgayThang ; \n typedef struct { \n char MSSV [ 10 ] ; \n char HoTen [ 40 ] ; \n NgayThang NgaySinh ; \n int Phai ; \n char DiaChi [ 40 ] ; \n } SinhVien ; \n / / Hàm in lên màn hình 1 mẩu tin SinhVien \n void InSV ( SinhVien s ) { \n printf ( \" MSSV : | Ho va ten | Ngay Sinh | \n Dia chi \\ n \" ) ; \n printf ( \" % s | % s | % d - % d - % d | % s \\ n \" , \n s . MSSV , s . HoTen , s . NgaySinh . Ngay , \n s . NgaySinh . Thang , s . NgaySinh . Nam , s . DiaChi ) ; \n } \n main ( ) { \n SinhVien SV , s ; \n printf ( \" Nhap MSSV : \" ) ; gets ( SV.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 130}}
{"text": ", s . HoTen , s . NgaySinh . Ngay , \n s . NgaySinh . Thang , s . NgaySinh . Nam , s . DiaChi ) ; \n } \n main ( ) { \n SinhVien SV , s ; \n printf ( \" Nhap MSSV : \" ) ; gets ( SV. MSSV ) ; \n printf ( \" Nhap Ho va ten : \" ) ; gets ( SV. HoTen ) ; \n printf ( \" Sinh ngay : \" ) ; \n scanf ( \" % d \" , & SV. NgaySinh . Ngay ) ;", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 130}}
{"text": "Lập trình căn bản \n printf ( \" Thang : \" ) ; \n scanf ( \" % d \" , & SV. NgaySinh . Thang ) ; \n printf ( \" Nam : \" ) ; scanf ( \" % d \" , & SV. NgaySinh . Nam ) ; \n printf ( \" Gioi tinh ( 0 : Nu ) , ( 1 : Nam ) : \" ) ; \n scanf ( \" % d \" , & SV. Phai ) ; \n fflush ( stdin ) ; \n printf ( \" Dia chi : \" ) ; gets ( SV. DiaChi ) ; \n InSV ( SV ) ; \n s = SV ; / / Gán trị cho cấu trúc s \n InSV ( s ) ; \n getch ( ) ; \n } \n Lưu ý : \n - Các biến cấu trúc có thể gán cho nhau . Thực chất đây là \n thao tác trên toàn bộ cấu trúc không phải trên một trường riêng rẽ \n nào . Chương trình trên dòng s = SV là một ví dụ . \n - Với các biến kiểu cấu trúc ta không thể thực hiện được \n các thao tác sau đây : \n o Sử dụng các hàm xuất nhập trên biến cấu trúc . \n o Các phép toán quan hệ , các phép toán số học và logic . \n Thí dụ 2 : Nhập vào hai số phức và tính tổng của chúng . Ta \n biết rằng số phức là một cặp ( a , b ) trong đó a , b là các số thực , a \n gọi là phần thực , b là phần ảo . ( Đôi khi người ta cũng viết số \n phức dưới dạng a + ib trong đó i là một đơn vị ảo có tính chất \n i2 = - 1 ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 131}}
{"text": "số \n phức dưới dạng a + ib trong đó i là một đơn vị ảo có tính chất \n i2 = - 1 ) . Gọi số phức c1 = ( a1 , b1 ) và c2 = ( a2 , b2 ) khi đó tổng của hai \n số phức c1 và c2 là một số phức c3 mà c3 = ( a1 + a2 , b1 + b2 ) . Với \n hiểu biết như vậy ta có thể xem mỗi số phức là một cấu trúc có \n hai trường , một trường biểu diễn cho phần thực , một trường biểu \n diễn cho phần ảo . Việc tính tổng của hai số phức được tính bằng \n cách lấy phần thực cộng với phần thực và phần ảo cộng với phần \n ảo .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 131}}
{"text": "Lập trình căn bản \n # include < conio . h > \n # include < stdio . h > \n # include < string . h > \n typedef struct { \n float Thuc ; \n float Ao ; \n } SoPhuc ; \n / / Hàm in số phức lên màn hình \n void InSoPhuc ( SoPhuc p ) { \n printf ( \" % . 2f + i % . 2f \\ n \" , p . Thuc , p . Ao ) ; \n } \n main ( ) { \n SoPhuc p1 , p2 , p ; \n printf ( \" Nhap so phuc thu nhat : \\ n \" ) ; \n printf ( \" Phan thuc : \" ) ; \n scanf ( \" % f \" , & p1 . Thuc ) ; \n printf ( \" Phan ao : \" ) ; scanf ( \" % f \" , & p1 . Ao ) ; \n printf ( \" Nhap so phuc thu hai : \\ n \" ) ; \n printf ( \" Phan thuc : \" ) ; \n scanf ( \" % f \" , & p2 . Thuc ) ; \n printf ( \" Phan ao : \" ) ; scanf ( \" % f \" , & p2 . Ao ) ; \n printf ( \" So phuc thu nhat : \" ) ; \n InSoPhuc ( p1 ) ; \n printf ( \" So phuc thu hai : \" ) ; \n InSoPhuc ( p2 ) ; \n p . Thuc = p1 . Thuc + p2 . Thuc ; \n p . Ao = p1 . Ao + p2 . Ao ; \n printf ( \" Tong 2 so phuc : \" ) ; \n InSoPhuc ( p ) ; \n getch ( ) ; \n } \n Kết quả thực hiện chương trình :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 132}}
{"text": "Lập trình căn bản \n II. 2 Khởi tạo cấu trúc \n Việc khởi tạo cấu trúc có thể được thực hiện trong lúc khai báo \n biến cấu trúc . Các trường của cấu trúc được khởi tạo được đặt \n giữa 2 dấu { và } , chúng được phân cách nhau bởi dấu phẩy ( , ) . \n Thí dụ : Khởi tạo biến cấu trúc NgaySinh : \n struct NgayThang NgaySinh = { 29 , 8 , 1986 } ; \n III. CON TRỎ CẤU TRÚC \n III. 1 Khai báo \n Việc khai báo một biến con trỏ kiểu cấu trúc cũng tương tự như \n khi khai báo một biến con trỏ khác , nghĩa là đặt thêm dấu * vào \n phía trước tên biến . \n Cú pháp : struct < Tên cấu trúc > * < Tên biến con trỏ > ; \n Thí dụ : Ta có thể khai báo một con trỏ cấu trúc kiểu \n NgayThang như sau : \n struct NgayThang * p ; \n hay NgayThang * p ; / / Nếu có định nghĩa kiểu \n III. 2 Sử dụng các con trỏ kiểu cấu trúc \n Khi khai báo biến con trỏ cấu trúc , biến con trỏ chưa chỉ đến 1 \n địa chỉ cụ thể . Lúc này nó chỉ mới được cấp phát 2 byte để lưu \n giữ địa chỉ và được ghi nhận là con trỏ chỉ đến 1 cấu trúc , nhưng \n chưa chỉ đến 1 đối tượng rõ ràng .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 133}}
{"text": "a chỉ đến 1 đối tượng rõ ràng . Muốn thao tác trên con trỏ cấu \n trúc hợp lệ , cũng tương tự như các con trỏ khác , ta phải : \n - Cấp phát một vùng nhớ cho nó ( sử dụng hàm malloc ( ) \n hay calloc ( ) ) \n - Hoặc , cho nó quản lý địa chỉ của một biến cấu trúc nào \n đó . \n Thí dụ : Sau khi khởi tạo giá trị của cấu trúc : \n struct NgayThang Ngay = { 29,8,1986 } ; \n p = & Ngay ; \n lúc này biến con trỏ p đã chứa địa chỉ của Ngay .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 133}}
{"text": "Lập trình căn bản \n III. 2 Truy cập các thành phần của cấu trúc đang được quản \n lý bởi con trỏ \n Để truy cập đến từng trường của 1 cấu trúc thông qua con trỏ của \n nó , ta sử dụng toán tử dấu mũi tên ( -> : dấu - và dấu > ) . \n Ngoài ra , ta vẫn có thể sử dụng đến phép toán * để truy cập vùng \n dữ liệu đang được quản lý bởi con trỏ cấu trúc để lấy thông tin \n cần thiết . \n Thí dụ : Sử dụng con trỏ cấu trúc . \n # include < conio . h > \n # include < stdio . h > \n typedef struct { \n unsigned char Ngay ; \n unsigned char Thang ; \n unsigned int Nam ; \n } NgayThang ; \n main ( ) { \n NgayThang Ng = { 29,8,1986 } ; \n NgayThang * p ; \n p = & Ng ; \n printf ( \" Truy cap binh thuong % d - % d - % d \\ n \" , \n Ng . Ngay , Ng . Thang , Ng . Nam ) ; \n printf ( \" Truy cap qua con tro % d - % d - % d \\ n \" , \n p -> Ngay , p -> Thang , p -> Nam ) ; \n printf ( \" Truy cap qua vung nho con tro \n % d - % d - % d \\ n \" , ( * p ) . Ngay , ( * p ) . Thang , ( * p ) . Nam ) ; \n getch ( ) ; \n } \n Kết quả :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 134}}
{"text": "Lập trình căn bản \n IV. BÀI TẬP \n 1 . Hãy định nghĩa kiểu : \n struct Hoso { \n char HoTen [ 40 ] ; \n float Diem ; \n char Loai [ 10 ] ; \n } ; \n Viết chương trình nhập vào họ tên , điểm của n học sinh . \n Xếp loại văn hóa theo cách sau : \n Điểm Xếp loại \n > = 9.0 Xuat sac \n 8.0 - < 9.0 Gioi \n 7.0 - < 8.0 Khá \n 5.0 - < 7.0 Trung bình \n < 5.0 Không đạt \n Hiển thị danh sách lên màn hình theo dạng sau ( thứ tự \n giảm dần theo điểm trung bình ) : \n XEP LOAI VAN HOA \n HO VA TEN DIEM XEP LOAI \n Nguyen Van A 7.0 Kha \n Ho Thi B 5.0 Trung binh \n Dang Kim C 4.0 Khong dat . Xem một phân số là một cấu trúc có hai trường là tử số và mẫu \n số . Hãy viết chương trình thực hiện các phép toán cộng , trừ , \n nhân , chia hai phân số . ( Các kết quả phải tối giản ) . \n 3 . Tạo một danh sách cán bộ công nhân viên , mỗi người người \n xem như một cấu trúc bao gồm các trường Ho , Ten , Luong , Tuoi , \n Diachi . Nhập một số người vào danh sách , sắp xếp tên theo thứ \n tự từ điển , in danh sách đã sắp xếp theo mẫu sau : \n DANH SACH CAN BO CONG NHAN VIEN \n STT HO VA TEN LUONG TUOI DIACHI \n 1 Nguyen Van A 333.00 26 Can Tho \n 2 Dang Kim B 290.00 23 Vinh Long", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 135}}
{"text": "sau : \n DANH SACH CAN BO CONG NHAN VIEN \n STT HO VA TEN LUONG TUOI DIACHI \n 1 Nguyen Van A 333.00 26 Can Tho \n 2 Dang Kim B 290.00 23 Vinh Long", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 135}}
{"text": "Lập trình căn bản \n Chương 10 \n TẬP TIN \n Các vấn đề được trình bày trong chương này : \n  Các khái niệm liên quan đến tập tin . \n  Các bước thao tác với tập tin . \n  Một số hàm truy xuất tập tin văn bản . \n  Một số hàm truy xuất tập tin nhị phân . \n I. MỘT SỐ KHÁI NIỆM VỀ TẬP TIN \n Đối với các kiểu dữ liệu ta đã biết như kiểu số , kiểu mảng , kiểu \n cấu trúc thì dữ liệu được tổ chức trong bộ nhớ trong ( RAM ) của \n máy tính nên khi kết thúc việc thực hiện chương trình thì dữ liệu \n cũng bị mất ; khi cần chúng ta bắt buộc phải nhập lại từ bàn phím . \n Điều đó vừa mất thời gian vừa không giải quyết được các bài \n toán với số liệu lớn . Để giải quyết vấn đề , người ta đưa ra kiểu \n tập tin ( file ) cho phép lưu trữ dữ liệu ở bộ nhớ ngoài ( đĩa ) . Khi \n kết thúc chương trình thì dữ liệu vẫn còn do đó chúng ta có thể sử \n dụng nhiều lần . Một đặc điểm khác của kiểu tập tin là kích thước \n lớn với số lượng các phần tử không hạn chế ( chỉ bị hạn chế bởi \n dung lượng của bộ nhớ ngoài ) . \n Có 2 loại dữ liệu kiểu tập tin : \n  Tập tin văn bản ( Text File ) : là loại tập tin dùng để ghi các \n ký tự lên đĩa .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 136}}
{"text": "Có 2 loại dữ liệu kiểu tập tin : \n  Tập tin văn bản ( Text File ) : là loại tập tin dùng để ghi các \n ký tự lên đĩa . Điểm đặc biệt là dữ liệu của tập tin được lưu trữ \n thành các dòng , mỗi dòng được kết thúc bằng ký tự xuống dòng \n ( new line ) , ký hiệu ‘ \\ n ’ ; ký tự này là sự kết hợp của 2 ký tự CR \n ( Carriage Return - Về đầu dòng , mã Ascii là 13 ) và LF ( Line \n Feed - Xuống dòng , mã Ascii là 10 ) . Mỗi tập tin được kết thúc \n bởi ký tự EOF ( End Of File ) có mã Ascii là 26 ( xác định bởi tổ \n hợp phím Ctrl + Z ) . \n Tập tin văn bản chỉ có thể truy xuất theo kiểu tuần tự .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 136}}
{"text": "Lập trình căn bản \n  Tập tin nhị phân : là loại tập tin chứa 1 dãy liên tục các \n byte ( mã Ascii của các ký tự ) . Tập tin nhị phân có 2 loại : \n o Tập tin định kiểu ( Typed File ) : là loại tập tin bao gồm \n nhiều phần tử có cùng kiểu : char , int , long , cấu trúc … và \n được lưu trữ trên đĩa dưới dạng một chuỗi các byte liên \n tục . \n o Tập tin không định kiểu ( Untyped File ) : là loại tập tin \n mà dữ liệu của chúng gồm các cấu trúc dữ liệu mà người \n ta không quan tâm đến nội dung hoặc kiểu của nó , chỉ lưu \n ý đến các yếu tố vật lý của tập tin như độ lớn và các yếu \n tố tác động lên tập tin mà thôi . \n Biến tập tin : là một biến thuộc kiểu dữ liệu tập tin dùng để đại \n diện cho một tập tin . Dữ liệu chứa trong một tập tin được truy \n xuất qua các thao tác với thông số là biến tập tin đại diện cho tập \n tin đó . \n Con trỏ tập tin : Khi một tập tin được mở ra để làm việc , tại mỗi \n thời điểm , sẽ có một vị trí của tập tin mà tại đó việc đọc / ghi \n thông tin sẽ xảy ra . Người ta hình dung có một con trỏ đang chỉ \n đến vị trí đó và đặt tên nó là con trỏ tập tin . \n Sau khi đọc / ghi xong dữ liệu , con trỏ sẽ chuyển dịch thêm một \n phần tử về phía cuối tập tin .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 137}}
{"text": "hình dung có một con trỏ đang chỉ \n đến vị trí đó và đặt tên nó là con trỏ tập tin . \n Sau khi đọc / ghi xong dữ liệu , con trỏ sẽ chuyển dịch thêm một \n phần tử về phía cuối tập tin . Sau phần tử dữ liệu cuối cùng của \n tập tin là dấu kết thúc tập tin EOF ( End Of File ) . \n II. CÁC THAO TÁC TRÊN TẬP TIN \n Muốn thao tác trên tập tin , ta phải lần lượt làm theo các bước : \n  Khai báo biến tập tin . \n  Mở tập tin bằng hàm fopen ( ) . \n  Thực hiện các thao tác xử lý dữ liệu của tập tin bằng các \n hàm đọc / ghi dữ liệu . \n  Đóng tập tin bằng hàm fclose ( ) . \n Lưu ý : Các thao tác liên quan đến tập tin sử dụng các hàm \n trong thư viện stdio . h .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 137}}
{"text": "Lập trình căn bản \n II. 1 . Khai báo biến tập tin \n Cú pháp : FILE < Danh sách các biến con trỏ > \n Các biến trong danh sách phải là các con trỏ và được phân \n cách bởi dấu phẩy ( , ) . \n Thí dụ : FILE * f1 , * f2 ; \n II. 2 . Mở tập tin \n Cú pháp : FILE * fopen ( char * Path , const char * Mode ) \n Trong đó : \n - Path : chuỗi chỉ đường dẫn đến tập tin trên đĩa . \n - Type : chuỗi xác định cách thức mà tập tin sẽ mở . Các giá \n trị có thể của Mode :\n\n| Chế độ | Ý nghĩa |\n| --- | --- |\n| r | Mở tập tin văn bản để đọc |\n| w | Tạo ra tập tin văn bản mới để ghi |\n| a | Nối vào tập tin văn bản |\n| rb | Mở tập tin nhị phân để đọc |\n| wb | Tạo ra tập tin nhị phân để ghi |\n| ab | Nối vào tập tin nhị phân |\n| r+ | Mở một tập tin văn bản để đọc/ghi |\n| w+ | Tạo ra tập tin văn bản để đọc ghi |\n| a+ | Nối vào hay tạo mới tập tin văn bản để đọc/ghi |\n| r+b | Mở ra tập tin nhị phân để đọc/ghi |\n| w+b | Tạo ra tập tin nhị phân để đọc/ghi |\n| a+b | Nối vào hay tạo mới tập tin nhị phân |\n\n\n- Hàm fopen trả về một con trỏ tập tin . Chương trình của \n ta không thể thay đổi giá trị của con trỏ này . Nếu có một lỗi xuất \n hiện trong khi mở tập tin thì hàm này trả về con trỏ NULL.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 138}}
{"text": "ả về một con trỏ tập tin . Chương trình của \n ta không thể thay đổi giá trị của con trỏ này . Nếu có một lỗi xuất \n hiện trong khi mở tập tin thì hàm này trả về con trỏ NULL. \n Thí dụ : Mở một tập tin tên TEST. txt để ghi . \n FILE * f ; \n f = fopen ( “ TEST. txt ” , “ w ” ) ; \n if ( f ! = NULL ) \n { \n / / Các câu lệnh để thao tác với tập tin \n / / Đóng tập tin \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 138}}
{"text": "Lập trình căn bản \n Trong thí dụ trên , ta có sử dụng câu lệnh kiểm tra điều \n kiện để xác định mở tập tin có thành công hay không ? . \n Nếu mở tập tin để ghi , nếu tập tin đã tồn tại rồi thì tập tin \n sẽ bị xóa và một tập tin mới được tạo ra . Nếu ta muốn ghi nối dữ \n liệu , ta phải sử dụng chế độ “ a ” . Khi mở với chế độ đọc , tập tin \n phải tồn tại rồi , nếu không một lỗi sẽ xuất hiện . \n II. 3 . Đóng tập tin \n Hàm fclose ( ) được dùng để đóng tập tin được mở bởi hàm \n fopen ( ) . Hàm này sẽ ghi dữ liệu còn lại trong vùng đệm vào tập \n tin và đóng lại tập tin . \n Cú pháp : int fclose ( FILE * f ) \n Trong đó f là con trỏ tập tin được mở bởi hàm fopen ( ) . Giá \n trị trả về của hàm là 0 báo rằng việc đóng tập tin thành công . \n Hàm trả về EOF nếu có xuất hiện lỗi . \n II. 4 . Kiểm tra đến cuối tập tin hay chưa ? \n Cú pháp : int feof ( FILE * f ) \n Ý nghĩa : Kiểm tra xem đã chạm tới cuối tập tin hay chưa \n và trả về EOF nếu cuối tập tin được chạm tới , ngược lại trả về 0 . \n II. 5 Di chuyển con trỏ tập tin về đầu tập tin - Hàm rewind ( ) \n Khi ta đang thao tác một tập tin đang mở , con trỏ tập tin luôn di \n chuyển về phía cuối tập tin .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 139}}
{"text": "huyển con trỏ tập tin về đầu tập tin - Hàm rewind ( ) \n Khi ta đang thao tác một tập tin đang mở , con trỏ tập tin luôn di \n chuyển về phía cuối tập tin . Muốn cho con trỏ quay về đầu tập tin \n như khi mở nó , ta sử dụng hàm rewind ( ) . \n Cú pháp : void rewind ( FILE * f ) \n III. TRUY CẬP TẬP TIN VĂN BẢN \n III. 1 . Ghi dữ liệu lên tập tin văn bản \n III. 1.1 Hàm putc ( ) : Hàm này được dùng để ghi một ký tự lên một \n tập tin văn bản đang được mở để làm việc . \n Cú pháp : int putc ( int c , FILE * f ) \n Trong đó , tham số c chứa mã Ascii của một ký tự nào đó . \n Mã này được ghi lên tập tin liên kết với con trỏ f . Hàm này trả về \n EOF nếu gặp lỗi .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 139}}
{"text": "Lập trình căn bản \n III. 1.2 Hàm fputs ( ) : Hàm này dùng để ghi một chuỗi ký tự chứa \n trong vùng đệm lên tập tin văn bản . \n Cú pháp : int puts ( const char * buffer , FILE * f ) \n Trong đó , buffer là con trỏ có kiểu char chỉ đến vị trí đầu \n tiên của chuỗi ký tự được ghi vào . Hàm này trả về giá trị 0 nếu \n buffer chứa chuỗi rỗng và trả về EOF nếu gặp lỗi . \n III. 1.3 Hàm fprintf ( ) : Hàm này dùng để ghi dữ liệu có định dạng \n lên tập tin văn bản . \n Cú pháp : void fprintf ( FILE * f , const char * format , varexpr ) \n Trong đó : format : chuỗi định dạng ( giống với các định \n dạng của hàm printf ( ) ) , varexpr : danh sách các biểu thức , mỗi \n biểu thức cách nhau dấu phẩy ( , ) . \n Thí dụ : Viết chương trình ghi chuỗi ký tự lên tập tin văn \n bản D : \\ \\ Baihat . txt \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n FILE * f ; \n f = fopen ( \" D : \\ \\ Baihat . txt \" , \" r + \" ) ; \n if ( f ! = NULL ) \n { \n fputs ( \" Em oi Ha Noi pho . \\ n \" , f ) ; \n fputs ( \" Ta con em , mui hoang lan ; ta con em , \n mui hoa sua . \" , f ) ; \n fclose ( f ) ; \n } \n getch ( ) ; \n } \n Nội dung tập tin Baihat . txt khi được mở bằng trình soạn thảo \n văn bản Notepad .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 140}}
{"text": "on em , mui hoang lan ; ta con em , \n mui hoa sua . \" , f ) ; \n fclose ( f ) ; \n } \n getch ( ) ; \n } \n Nội dung tập tin Baihat . txt khi được mở bằng trình soạn thảo \n văn bản Notepad .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 140}}
{"text": "Lập trình căn bản \n III. 2 . Đọc dữ liệu từ tập tin văn bản \n III. 2.1 Hàm getc ( ) : Hàm này dùng để đọc dữ liệu từ tập tin văn \n bản đang được mở để làm việc . \n Cú pháp : int getc ( FILE * f ) \n Hàm này trả về mã Ascii của một ký tự nào đó ( kể cả \n EOF ) trong tập tin liên kết với con trỏ f . \n III. 2.2 Hàm fgets ( ) \n Cú pháp : char * fgets ( char * buffer , int n , FILE * f ) \n Hàm này được dùng để đọc một chuỗi ký tự từ tập tin văn \n bản đang được mở ra và liên kết với con trỏ f cho đến khi đọc đủ \n n ký tự hoặc gặp ký tự xuống dòng ‘ \\ n ’ ( ký tự này cũng được đưa \n vào chuỗi kết quả ) hay gặp ký tự kết thúc EOF ( ký tự này không \n được đưa vào chuỗi kết quả ) . \n Trong đó : \n - buffer ( vùng đệm ) : con trỏ có kiểu char chỉ đến cùng nhớ \n đủ lớn chứa các ký tự nhận được . \n - n : giá trị nguyên chỉ độ dài lớn nhất của chuỗi ký tự nhận \n được . \n - f : con trỏ liên kết với một tập tin nào đó . \n - Ký tự NULL ( ‘ \\ 0 ’ ) tự động được thêm vào cuối chuỗi kết \n quả lưu trong vùng đêm . \n - Hàm trả về địa chỉ đầu tiên của vùng đệm khi không gặp \n lỗi và chưa gặp ký tự kết thúc EOF. Ngược lại , hàm trả về giá trị \n NULL. \n III. 2.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 141}}
{"text": "đêm . \n - Hàm trả về địa chỉ đầu tiên của vùng đệm khi không gặp \n lỗi và chưa gặp ký tự kết thúc EOF. Ngược lại , hàm trả về giá trị \n NULL. \n III. 2.3 Hàm fscanf ( ) : Hàm này dùng để đọc dữ liệu từ tập tin văn \n bản vào danh sách các biến theo định dạng . \n Cú pháp : void fscanf ( FILE * f , const char * format , pointers ) \n Trong đó : format : chuỗi định dạng ( giống hàm scanf ( ) ) ; \n pointers : danh sách địa chỉ các biến mỗi biến cách nhau dấu phẩy \n ( , ) .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 141}}
{"text": "Lập trình căn bản \n Thí dụ : Viết chương trình chép tập tin D : \\ Baihat . txt ở trên \n sang tập tin D : \\ Baica . txt . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n FILE * f1 , * f2 ; \n f1 = fopen ( \" D : \\ \\ Baihat . txt \" , \" rt \" ) ; \n f2 = fopen ( \" D : \\ \\ Baica . txt \" , \" wt \" ) ; \n if ( f1 ! = NULL & & f2 ! = NULL ) \n { \n int ch = fgetc ( f1 ) ; \n while ( ! feof ( f1 ) ) \n { \n fputc ( ch , f2 ) ; \n ch = fgetc ( f1 ) ; \n } \n fclose ( f1 ) ; \n fclose ( f2 ) ; \n } \n getch ( ) ; \n } \n IV. TRUY CẬP TẬP TIN NHỊ PHÂN \n IV. 1 Ghi dữ liệu lên tập tin nhị phân - Hàm fwrite ( ) \n Cú pháp : \n size t fwrite ( const void * ptr , size t size , size t n , FILE * f ) \n Trong đó : \n - ptr : con trỏ chỉ đến vùng nhớ chứa thông tin cần ghi lên \n tập tin . \n - n : số phần tử sẽ ghi lên tập tin . \n - size : kích thước của mỗi phần tử . \n - f : con trỏ tập tin đã được mở . \n - Giá trị trả về của hàm này là số phần tử được ghi lên tập \n tin . Giá trị này bằng n trừ khi xuất hiện lỗi . \n IV. 2 Đọc dữ liệu từ tập tin nhị phân - Hàm fread ( ) \n Cú pháp : \n size t fread ( const void * ptr , size t size , size t n , FILE * f )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 142}}
{"text": "lỗi . \n IV. 2 Đọc dữ liệu từ tập tin nhị phân - Hàm fread ( ) \n Cú pháp : \n size t fread ( const void * ptr , size t size , size t n , FILE * f )", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 142}}
{"text": "Lập trình căn bản \n Trong đó : \n - ptr : con trỏ chỉ đến vùng nhớ sẽ nhận dữ liệu từ tập tin . \n - n : số phần tử được đọc từ tập tin . \n - size : kích thước của mỗi phần tử . \n - f : con trỏ tập tin đã được mở . \n - Giá trị trả về của hàm này là số phần tử đã đọc được từ \n tập tin . Giá trị này bằng n hay nhỏ hơn n nếu đã chạm đến cuối \n tập tin hoặc có lỗi xuất hiện . . \n IV. 3 Di chuyển con trỏ tập tin - Hàm fseek ( ) \n Việc ghi hay đọc dữ liệu từ tập tin sẽ làm cho con trỏ tập tin dịch \n chuyển một số byte , đây chính là kích thước của kiểu dữ liệu của \n mỗi phần tử của tập tin . \n Khi đóng tập tin rồi mở lại nó , con trỏ luôn ở vị trí ngay đầu tập \n tin . Nhưng nếu ta sử dụng kiểu mở tập tin là “ a ” để ghi nối dữ \n liệu , con trỏ tập tin sẽ di chuyển đến vị trí cuối cùng của tập tin \n này . \n Ta cũng có thể điều khiển việc di chuyển con trỏ tập tin đến vị trí \n chỉ định bằng hàm fseek ( ) . \n Cú pháp : int fseek ( FILE * f , long offset , int whence ) \n Trong đó : \n - f : con trỏ tập tin đang thao tác . \n - offset : số byte cần dịch chuyển con trỏ tập tin kể từ vị \n trí trước đó . Phần tử đầu tiên là vị trí 0 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 143}}
{"text": "tập tin đang thao tác . \n - offset : số byte cần dịch chuyển con trỏ tập tin kể từ vị \n trí trước đó . Phần tử đầu tiên là vị trí 0 . \n - whence : vị trí bắt đầu để tính offset , ta có thể chọn \n điểm xuất phát là :\n\n| 0 | SEEK SET | Vị trí đầu tập tin |\n| --- | --- | --- |\n| 1 | SEEK CUR | Vị trí hiện tại của con trỏ tập tin |\n| 2 | SEEK END | Vị trí cuối tập tin |\n\n\n- Kết quả trả về của hàm là 0 nếu việc di chuyển thành \n công . Nếu không thành công , 1 giá trị khác 0 ( đó là 1 \n mã lỗi ) được trả về .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 143}}
{"text": "Lập trình căn bản \n IV. 3 Thí dụ \n Thí dụ 1 : Viết chương trình ghi lên tập tin CacSo . Dat 3 giá \n trị số ( thực , nguyên , nguyên dài ) . Sau đó đọc các số từ tập tin vừa \n ghi và hiển thị lên màn hình . \n # include < stdio . h > \n # include < conio . h > \n main ( ) { \n FILE * f ; \n f = fopen ( \" D : \\ \\ CacSo . txt \" , \" wb \" ) ; \n if ( f ! = NULL ) \n { \n double d = 3.14 ; \n int i = 101 ; \n long l = 54321 ; \n fwrite ( & d , sizeof ( double ) , 1 , f ) ; \n fwrite ( & i , sizeof ( int ) , 1 , f ) ; \n fwrite ( & l , sizeof ( long ) , 1 , f ) ; \n / / Doc tu tap tin \n rewind ( f ) ; \n fread ( & d , sizeof ( double ) , 1 , f ) ; \n fread ( & i , sizeof ( int ) , 1 , f ) ; \n fread ( & l , sizeof ( long ) , 1 , f ) ; \n printf ( \" Cac ket qua la : % f % d % ld \" , \n d , i , l ) ; \n fclose ( f ) ; \n } \n getch ( ) ; \n } \n Thí dụ 2 : Mỗi sinh viên cần quản lý ít nhất 2 thông tin : mã \n sinh viên và họ tên . Viết chương trình cho phép lựa chọn các \n chức năng : nhập danh sách sinh viên từ bàn phím rồi ghi lên tập \n tin SinhVien . dat , đọc dữ liệu từ tập tin SinhVien .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 144}}
{"text": "m rồi ghi lên tập \n tin SinhVien . dat , đọc dữ liệu từ tập tin SinhVien . dat rồi hiển thị \n danh sách lên màn hình , tìm kiếm họ tên của một sinh viên nào \n đó dựa vào mã sinh viên nhập từ bàn phím . \n Ta nhận thấy rằng mỗi phần tử của tập tin SinhVien . Dat là \n một cấu trúc có 2 trường : mã và họ tên . Do đó , ta cần khai báo \n cấu trúc này và sử dụng các hàm đọc / ghi tập tin nhị phân với kích \n thước mỗi phần tử của tập tin là chính kích thước cấu trúc đó .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 144}}
{"text": "Lập trình căn bản \n # include < stdio . h > \n # include < conio . h > \n # include < string . h > \n typedef struct { \n char Ma [ 10 ] ; \n char HoTen [ 40 ] ; \n } SinhVien ; \n void WriteFile ( char * FileName ) { \n FILE * f ; \n int n , i ; \n SinhVien sv ; \n f = fopen ( FileName , \" ab \" ) ; \n if ( f = = NULL ) return ; \n printf ( \" Nhap bao nhieu sinh vien ? \" ) ; \n scanf ( \" % d \" , & n ) ; \n fflush ( stdin ) ; \n for ( i = 1 ; i < = n ; i + + ) { \n printf ( \" Sinh vien thu % i \\ n \" , i ) ; \n printf ( \" - MSSV : \" ) ; gets ( sv . Ma ) ; \n printf ( \" - Ho ten : \" ) ; gets ( sv . HoTen ) ; \n fwrite ( & sv , sizeof ( sv ) , 1 , f ) ; \n fflush ( stdin ) ; \n } \n fclose ( f ) ; \n printf ( \" Bam phim bat ky de tiep tuc \" ) ; \n getch ( ) ; \n } \n void ReadFile ( char * FileName ) { \n FILE * f ; \n SinhVien sv ; \n f = fopen ( FileName , \" rb \" ) ; \n if ( f = = NULL ) return ; \n printf ( \" MSSV | Ho va ten \\ n \" ) ; \n fread ( & sv , sizeof ( sv ) , 1 , f ) ; \n while ( ! feof ( f ) ) { \n printf ( \" % s | % s \\ n \" , \n sv . Ma , sv . HoTen ) ; \n fread ( & sv , sizeof ( sv ) , 1 , f ) ; \n } \n fclose ( f ) ; \n printf ( \" Bam phim bat ky de tiep tuc ! ! ! \" ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 145}}
{"text": "% s | % s \\ n \" , \n sv . Ma , sv . HoTen ) ; \n fread ( & sv , sizeof ( sv ) , 1 , f ) ; \n } \n fclose ( f ) ; \n printf ( \" Bam phim bat ky de tiep tuc ! ! ! \" ) ; \n getch ( ) ; \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 145}}
{"text": "Lập trình căn bản \n void Search ( char * FileName ) { \n char MSSV [ 10 ] ; \n FILE * f ; \n int Found ; \n SinhVien sv ; \n fflush ( stdin ) ; \n printf ( \" Ma so sinh vien can tim : \" ) ; \n gets ( MSSV ) ; \n Found = 0 ; \n f = fopen ( FileName , \" rb \" ) ; \n if ( f = = NULL ) return ; \n while ( ! feof ( f ) & & Found = = 0 ) { \n fread ( & sv , sizeof ( sv ) , 1 , f ) ; \n if ( strcmp ( sv . Ma , MSSV ) = = 0 ) Found = 1 ; \n } \n fclose ( f ) ; \n if ( Found = = 1 ) \n printf ( \" Tim thay SV co ma % s . Ho ten la : % s \" , \n sv . Ma , sv . HoTen ) ; \n else \n printf ( \" Tim khong thay sinh vien co ma % s \" , \n MSSV ) ; \n printf ( \" \\ nBam phim bat ky de tiep tuc ! ! ! \" ) ; \n getch ( ) ; \n } \n main ( ) { \n int c ; \n for ( ; ; ) { \n printf ( \" 1 . Nhap DSSV \\ n \" ) ; \n printf ( \" 2 . In DSSV \\ n \" ) ; \n printf ( \" 3 . Tim kiem \\ n \" ) ; \n printf ( \" 4 . Thoat \\ n \" ) ; \n printf ( \" Ban chon 1 , 2 , 3 , 4 : \" ) ; \n scanf ( \" % d \" , & c ) ; \n if ( c = = 1 ) \n WriteFile ( \" d : \\ \\ SinhVien . Dat \" ) ; \n else if ( c = = 2 ) \n ReadFile ( \" d : \\ \\ SinhVien . Dat \" ) ; \n else if ( c = = 3 ) \n Search ( \" d : \\ \\ SinhVien . Dat \" ) ; \n else break ; \n } \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 146}}
{"text": ") ; \n else if ( c = = 2 ) \n ReadFile ( \" d : \\ \\ SinhVien . Dat \" ) ; \n else if ( c = = 3 ) \n Search ( \" d : \\ \\ SinhVien . Dat \" ) ; \n else break ; \n } \n }", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 146}}
{"text": "Lập trình căn bản \n V. BÀI TẬP \n 1 . Viết chương trình quản lý một tập tin văn bản theo các yêu \n cầu : \n - Nhập từ bàn phím nội dung một văn bản sau đó ghi vào \n đĩa . \n - Đọc từ đĩa nội dung văn bản vừa nhập và in lên màn \n hình . \n - Đọc từ đĩa nội dung văn bản vừa nhập , in nội dung đó \n lên màn hình và cho phép nối thêm thông tin vào cuối tập tin đó . \n 2 . Viết chương trình cho phép thống kê số lần xuất hiện của các \n ký tự là chữ ( ‘ A ’ . . ’ Z ’ , ’ a ’ . . ’ z ’ ) trong một tập tin văn bản . \n 3 . Viết chương trình đếm số từ và số dòng trong một tập tin văn \n bản . \n 4 . Viết chương trình nhập từ bàn phím và ghi vào 1 tập tin tên là \n DMHH. DAT với mỗi phần tử của tập tin là 1 cấu trúc bao gồm \n các trường : Ma ( mã hàng : char [ 5 ] ) , Ten ( Tên hàng : char [ 20 ] ) . Kết \n thúc việc nhập bằng cách gõ ENTER vào Ma . Ta sẽ dùng tập tin \n này để giải mã hàng hóa cho tập tin DSHH. DAT sẽ đề cập trong \n bài 5 . \n 5 . Viết chương trình cho phép nhập từ bàn phím và ghi vào 1 tập \n tin tên DSHH.", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 147}}
{"text": "tin tên DSHH. Dat với mỗi phần tử của tập tin là một cấu trúc bao \n gồm các trường : mh ( mã hàng : char [ 5 ] ) , sl ( số lượng : int ) , dg ( \n đơn giá : float ) , st ( Số tiền : float ) theo yêu cầu : \n - Mỗi lần nhập một cấu trúc \n - Trước tiên nhập mã hàng ( mh ) , đưa mh so sánh với Ma \n trong tập tin DMHH. DAT đã được tạo ra bởi bài tập 4 , nếu \n mh = ma thì in tên hàng ngay bên cạnh mã hàng . \n - Nhập số lượng ( sl ) . \n - Nhập đơn giá ( dg ) . \n - Tính số tiền = số lượng * đơn giá . \n Kết thúc việc nhập bằng cách đánh ENTER vào mã hàng . \n Sau khi nhập xong yêu cầu in toàn bộ danh sách hàng hóa có sự \n giải mã về tên hàng theo mẫu sau :", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 147}}
{"text": "Lập trình căn bản\n\n| STT | MA HANG | TEN HANG | SOLG | DON GIA | SO TIEN |\n| --- | --- | --- | --- | --- | --- |\n| 1 2 | a0101 b0101 | Duong cat trang Sua co gai Ha Lan | 25 10 | 10000.00 40000.00 | 250000.00 400000.00 |", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 148}}
{"text": "Lập trình căn bản \n TÀI LIỆU THAM KHẢO \n [ 1 ] Nguyễn Văn Linh , Giáo trình Tin Học Đại Cương A , Khoa \n Công Nghệ Thông Tin , Đại học Cần Thơ , 1991 . \n [ 2 ] Nguyễn Đình Tê , Hoàng Đức Hải , Giáo trình lý thuyết và bài \n tập ngôn ngữ C ; Nhà xuất bản Giáo dục , 1999 . \n [ 3 ] Nguyễn Cẩn , C – Tham khảo toàn diện , Nhà xuất bản Đồng \n Nai , 1996 . \n [ 4 ] Võ Văn Viện , Giúp tự học Lập Trình với ngôn ngữ C , Nhà \n xuất bản Đồng Nai , 2002 . \n [ 5 ] Brain W. Kernighan & Dennis Ritchie , The C Programming \n Language , Prentice Hall Publisher , 1988 . \n [ 6 ] Trần Đức Huyên , Phương pháp giải các bài toán trong Tin học , \n Nhà xuất bản Giáo dục , 2003 .", "metadata": {"source": "Giao Trinh_Lap_Trinh_Can_Ban_A_V2.pdf", "page": 149}}
